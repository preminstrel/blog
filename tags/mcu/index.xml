<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MCU on Blog de Preminstrel</title>
    <link>https://preminstrel.github.io/blog/tags/mcu/</link>
    <description>Recent content in MCU on Blog de Preminstrel</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <managingEditor>preminstrel@gmail.com (Hanshi Sun)</managingEditor>
    <webMaster>preminstrel@gmail.com (Hanshi Sun)</webMaster>
    <lastBuildDate>Fri, 29 Oct 2021 17:40:03 +0800</lastBuildDate><atom:link href="https://preminstrel.github.io/blog/tags/mcu/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DC/DC 开关电源</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/29/dcdc-%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/</link>
      <pubDate>Fri, 29 Oct 2021 17:40:03 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/29/dcdc-%E5%BC%80%E5%85%B3%E7%94%B5%E6%BA%90/</guid>
      
      <description>&lt;p&gt;开关电源是一种高频化电能转换装置，其主要利用电力电子开关器件(如晶体管、MOS管、可控晶闸管等)，通过控制电路，使电子开关器件周期性地&amp;quot;接通&amp;quot;和&amp;quot;关断&amp;rdquo;，让电力电子开关器件对输入电压进行脉冲调制，从而实现电压变换以及输出电压可调和自动稳压的功能。按照调制方式的不同可分为脉宽调制(PWM)和脉频调制(PFM)两种，目前&lt;strong&gt;脉宽调制&lt;/strong&gt;在开关电源中占据主导地位。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开关电源的优势&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功耗低，效率高&lt;/li&gt;
&lt;li&gt;体积小，重量轻&lt;/li&gt;
&lt;li&gt;稳压范围宽&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开关电源的损耗来源&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开关管损耗&lt;/li&gt;
&lt;li&gt;电感电容损耗&lt;/li&gt;
&lt;li&gt;二级管损耗&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;开关电源的损耗分析：开关电源的效率可以达到 90% 以上，如果精心优化与设计，甚至可以达到 95% 以上，这在以电池作为电力来源的场合非常重要，例如手机、小型无人机等。&lt;strong&gt;因此开关电源设计的优劣程度将直接影响设备的续航能力&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;开关管损耗：这是开关电源的主要损耗，主要包括开关损耗、导通损耗。因此应该尽量选择导通电阻比较小的开关管作为开关电源的核心元器件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;电感电容损耗：电感损耗主要包括直流电阻损耗，电容损耗主要包括漏电流损耗。因此应该尽量选择直流电阻较小的电感和漏电流较小的电容元器件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二极管损耗：主要包括导通损耗和开关损耗。因此应该尽量选择导通压降较小，反向恢复时间较短的二极管，例如肖特基二极管或快恢复二极管等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;buck-型-dc-dc&#34;&gt;Buck 型 DC-DC&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;非同步整流 Buck 型开关电源的典型拓扑：&lt;/strong&gt;&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/201910120900307.png&#34; width=&#34;500px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;实际电路结构中，使用场效应管或者三极管当作图中的开关，开关周期性地接通和断开，由于电感和电容的滤波作用，使负载上得到一个直流的电压。由于开关管要么断开，要么饱和，所以损耗比较小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步整流 Buck 型开关电源的典型拓扑：&lt;/strong&gt;&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/2019101209013774.png&#34; width=&#34;400px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;同步整流 Buck 型开关电源的工作原理与非同步的基本相当，只不过将续流二极管换成了MOS管（称之为同步整流管），DC-DC 芯片需同时控制MOS 管Q1、Q2 的开关。&lt;/p&gt;
&lt;h1 id=&#34;buck-型开关电源原理&#34;&gt;Buck 型开关电源原理&lt;/h1&gt;
&lt;p&gt;Buck 型开关电源主要由开关管、储能电感、输出电容以及续流二极管组成，并通过负反馈回路维持输出Vo的稳定。忽略电路损耗，输入输出满足：&lt;/p&gt;
&lt;p&gt;$$\frac{V_\text{O}}{V_\text{IN}}=\frac{T_\text{ON}}{T_\text{O}}$$&lt;/p&gt;
&lt;p&gt;基本框图与主要点波形如下图所示。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/2019101209041589.png&#34; width=&#34;500px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;Q1 导通时，输入通过Q1 对电感进行充电，电感电流线性增大，如上图（d）所示，满足条件：&lt;/p&gt;
&lt;p&gt;$$V_\text{IN}-V_\text{O}=L_\text{O}*\frac{dI}{dt}$$&lt;/p&gt;
&lt;p&gt;当 Q1 关断时，由于流经电感的电流不能突变，关断瞬间电流有快速降低的趋势，由楞次定律可知，电感内磁场会产生反向的感应电动势以阻止电流减小，这种瞬间的电压颠倒的现象称为“电感反冲”，此时因为有续流二极管的存在，将 V1 点电压强制钳位于地，保证 V1 不会由于“电感反冲”变得很“负”，从而保证 Q1 的可靠关断。所以 Q1 关断以后电感电流保持线性降低，直至下个周期开关打开，如上图（e）所示。满足：
​
$$-V_\text{O}=L_\text{O}*\frac{dI}{dt}$$&lt;/p&gt;
&lt;p&gt;所以，最终电感上的电流为 Q1 打开和关断状态之和，如上图（f）所示，在输出稳定的情况下，开关周期是基本上固定的，所以直流输出电流也就是经过上图（f）斜坡中点的那条直流分量，实际的工作可能由于负载变化等原因，直流输出电流会有相应的增加或减少，但是斜坡的斜率是不会变化的，所以可以得到斜坡起始值和峰值是由直流输出电流决定的。&lt;/p&gt;
&lt;p&gt;另外，上图（a）和（b）表示了控制芯片根据输出电压来形成一定占空比的 PWM 波形的原理：（a）的三角波是芯片内部产生的振荡波形，中间的直线是误差放大器根据输出电压产生的电平，两个波形对比，即产生（b）所示的方波，当然这只是一个简化，不同的芯片其控制机理也有比较大的区别。&lt;/p&gt;
&lt;h1 id=&#34;电感工作模式选择&#34;&gt;电感工作模式选择&lt;/h1&gt;
&lt;p&gt;按电感电流是否从 0 开始，可分为电感电流连续工作模式和电感电流不连续工作模式，如下图：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20191012090658415.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;图（a） 中， 电感电流处于连续工作模式， 电感起始电流 $I_a$ 大于 0 ， 稳定时输出电流&lt;/p&gt;
&lt;p&gt;$$I_\text{O}=\frac{I_a+I_b}{2}$$
​
图（b）中，电感工作在不连续状态，电感起始电流为 0 且最大值大于 $2I_\text{O}$ 。实际电路中，如果电感较小，且负载较轻，则电感电流可能降低为 0 而进入不连续模式，电感进入不连续模式波形如下图：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20191012092133824.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;图中明显可以看到，电感电流不连续时，有明显阻尼振荡，即所谓的“振铃现象”。虽然电感不连续时，反馈回路仍然能够通过调整开关状态维持输出电压稳定，但是在一些BUCK型输出滤波器的拓扑却会在非连续模式下出现问题，电路设计尽量避免不连续状态出现。&lt;/p&gt;
&lt;h1 id=&#34;buck-转换器的纹波&#34;&gt;Buck 转换器的纹波&lt;/h1&gt;
&lt;p&gt;电压纹波是指叠加在输出稳定电压上的变化的电压。开关电源的纹波，一般指 20MHz 以内的电压波动成分，所以测量纹波时需打开示波器的带宽限制功能，对输入信号作 20MHz 低通滤波处理。更高频的波动，一般称为高频噪声。由于Buck转换器在工作过程中，输出电容 C 会不断地充放电，所以会产生输出电压 $V_\text{O}$ 的波动，这是 Buck 转换器固有的纹波。从 LC 滤波的角度看，增大 L 和 C 可以降低 LC 滤波器的截止频率，从而减小纹波。&lt;/p&gt;
&lt;p&gt;纹波的另一个重要来源是输出电容 C 的等效串联电阻(ESR)，充放电的电流在 ESR 上产生压降，进一步增大了纹波。铝电解电容的容量较大，但是 ESR 也较大，所以一般另加 ESR 较小的陶瓷电容与电解电容并联组成输出电容。&lt;/p&gt;
&lt;h1 id=&#34;dc-dc-电源芯片的选择&#34;&gt;DC-DC 电源芯片的选择&lt;/h1&gt;
&lt;p&gt;主要考虑因素：输入电压、输出电压、最大输出电流。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果输入电压和输出电压很接近，最好是选用 LDO 稳压器，可达到很高的效率。&lt;/li&gt;
&lt;li&gt;如果输入和输出不是很接近，就要考虑开关型 DC-DC 了。此时若使用 LDO，功耗大，效率低。&lt;/li&gt;
&lt;li&gt;开关频率的选取主要考虑 LC 电路体积与开关损耗、音频噪声等因素。高开关频率可以减小滤波电路 LC 的体积，但同时增加开关损耗，降低效率；开关频率过低，可能产生音频噪声。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在选择 DC-DC 芯片时除了考虑以上三点外，还需考虑整机功耗，转换效率，电源纹波等因素，结合实际情况，选择合适的 DC-DC电源芯片。&lt;/p&gt;
&lt;h1 id=&#34;与-ldo-的区别&#34;&gt;与 LDO 的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;LDO&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;低压差线性稳压器，故名思意，为线性的稳压器，仅能使用在降压应用中。输出电压必需小于输入电压。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：稳定性好，负载响应快。输出纹波小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：效率低，输入输出的电压差不能太大。负载不能太大，目前最大的 LDO 为 5A（但要保证5A的输出还有很多的限制条件）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;DC-DC&lt;/strong&gt;&lt;/em&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;直流电压转直流电压。严格来讲，LDO 也是 DC-DC 的一种，但目前 DC-DC 多指开关电源。&lt;/p&gt;
&lt;p&gt;具有很&lt;strong&gt;多种拓朴结构&lt;/strong&gt;，如 BUCK，BOOST，等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：效率高，输入电压范围较宽。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：负载响应比 LDO 差，输出纹波比 LDO 大。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>LDO</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/29/ldo/</link>
      <pubDate>Fri, 29 Oct 2021 13:03:54 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/29/ldo/</guid>
      
      <description>&lt;p&gt;&lt;em&gt;&lt;strong&gt;LDO (Low Dropout Regulator)&lt;/strong&gt;&lt;/em&gt; 低压差稳压器在电源设计中用途十分广泛。相比于 &lt;em&gt;&lt;strong&gt;DC-DC&lt;/strong&gt;&lt;/em&gt; 稳压器，LDO 具有噪声小，芯片尺寸小，外围器件少且设计简单等优点；也存在输入输出电压压差大时导致效率低且发热量大，只能降压使用等缺点。低压差稳压器是一种直流线性稳压器，即使在电源电压非常接近输出电压时也能调节输出电压。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211029133101.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;h1 id=&#34;regulation&#34;&gt;Regulation&lt;/h1&gt;
&lt;p&gt;误差放大器的引脚电压与基准电压 ($V_{\text{REF}}$) 相同，因此输出电压值（$V_\text{O}$）由两个电阻（$R_1$ 和 $R_2$）的阻值比决定。&lt;/p&gt;
&lt;p&gt;$$V_\text{O}=\left(1+\frac{R_1}{R_2}\right) V_{\text{REF}}$$&lt;/p&gt;
&lt;p&gt;该电路主要是由串联调整管、取样电阻、比较放大器组成。取样电压加在比较放大器的同相输入端，与加在反相输入端的基准电压 $V_{\text{REF}}$ 相比较，两者的差值经放大器放大后，控制串联调整管的压降，从而稳定输出电压。当输出电压 $V_\text{O}$ 降低时，基准电压与取样电压的差值增加，比较放大器输出的驱动电流增加，串联调整管压降减小，从而使输出电压升高。相反，若输出电压 $V_\text{O}$ 超过所需要的设定值，比较放大器输出的前驱动电流减小，从而使输出电压降低。&lt;/p&gt;
&lt;p&gt;供电过程中，输出电压校正连续进行，调整时间只受比较放大器和串联调整管回路反应速度的限制。环路内的&lt;strong&gt;负反馈&lt;/strong&gt;总是强制比较放大器调节输入两端的电压使其相等。&lt;/p&gt;
&lt;p&gt;负反馈回路以保持输出电压的稳定。但反馈信号在通过回路后都有一定的增益和相位变化。如果反馈信号相位有 $180^{\circ}$ 变化，负反馈就会变成正反馈，造成输出不稳定。因此反馈信号经过整个回路的相位偏移，需要有至少 $20^{\circ}$ 的相位裕度，才能保证电路的稳定。（相位裕度定义为回路总的相位偏移与 $-180^{\circ}$ 的差）&lt;/p&gt;
&lt;h1 id=&#34;efficiency-and-heat-dissipation&#34;&gt;Efficiency and heat dissipation&lt;/h1&gt;
&lt;p&gt;典型 LDO 的传输元件和内部电路 $({\displaystyle P_{\text{LOSS}}})$ 中的功耗计算如下：&lt;/p&gt;
&lt;p&gt;$${\displaystyle P_{\text{LOSS}}=\left(V_{\text{IN}}-V_{\text{OUT}}\right)I_{\text{OUT}}+V_{\text{IN }}I_{\text{Q}}}$$&lt;/p&gt;
&lt;p&gt;其中 ${\displaystyle I_{\text{Q}}}$ 是 LDO 内部电路所需的静态电流。因此，可以按如下方式计算效率：&lt;/p&gt;
&lt;p&gt;$${\displaystyle \eta ={\frac {P_{\text{IN}}-P_{\text{LOSS}}}{P_{\text{IN}}}}} 其中 {\displaystyle P_{\text{IN }}=V_{\text{IN}}I_{\text{IN}}}$$&lt;/p&gt;
&lt;p&gt;但是，当 LDO 处于完全运行状态（即向负载提供电流）时，通常：${\displaystyle I_{\text{OUT}}\gg I_{\text{Q}}}$。这使我们可以将 ${\displaystyle P_{\text{LOSS}}}$ 简化为以下内容：&lt;/p&gt;
&lt;p&gt;$${\displaystyle P_{\text{LOSS}}=\left(V_{\text{IN}}-V_{\text{OUT}}\right)I_{\text{OUT}}}$$
这进一步将效率方程简化为：&lt;/p&gt;
&lt;p&gt;$${\displaystyle \eta ={\frac {V_{\text{OUT}}}{V_{\text{IN}}}}}$$&lt;/p&gt;
&lt;p&gt;使用低压差线性稳压器时，务必牢记散热考虑。输入和输出电压之间的高电流和/或宽差可能会&lt;strong&gt;导致大功率耗散&lt;/strong&gt;。此外，随着差异的扩大，效率将受到影响。根据封装的不同，过度的功耗可能会损坏 LDO 或导致其进入热关断状态。&lt;/p&gt;
&lt;h1 id=&#34;quiescent-current&#34;&gt;Quiescent current&lt;/h1&gt;
&lt;p&gt;线性稳压器的其他重要特性之一是&lt;strong&gt;静态电流&lt;/strong&gt;，也称为接地电流或电源电流，它解释了 LDO 的输入和输出电流之间的差异（尽管很小），即：&lt;/p&gt;
&lt;p&gt;$${\displaystyle I_{\text{Q}}=I_{\text{IN}}-I_{\text{OUT}}}{\displaystyle I_{\text{Q}}=I_{\text{IN}}-I_{\text{OUT}}}$$&lt;/p&gt;
&lt;p&gt;静态电流是由 LDO 汲取的电流，以控制其内部电路以使其正常运行。串联传输元件、拓扑结构和环境温度是静态电流的主要贡献者。&lt;/p&gt;
&lt;p&gt;许多应用不需要 LDO 一直处于完全运行状态（即向负载提供电流）。在此空闲状态下，LDO 仍会吸收少量静态电流，以便在出现负载时保持内部电路准备就绪。当没有电流被提供给负载时， ${\displaystyle P_{\text{LOSS}}}$ 可以表示如下：&lt;/p&gt;
&lt;p&gt;$${\displaystyle P_{\text{LOSS}}=V_{\text{IN}}I_{Q}}{\displaystyle P_{\text{LOSS}}=V_{\text{IN}}I_{Q}}$$&lt;/p&gt;
&lt;h1 id=&#34;filtering&#34;&gt;Filtering&lt;/h1&gt;
&lt;p&gt;除了调节电压外，LDO 还可以用作滤波器。这在系统使用开关器时特别有用，因为开关器会在开关频率处引入输出电压中的纹波。如果不理会，这种纹波有可能对振荡器、数据转换器、和由切换器供电的射频系统的性能产生不利影响。然而，任何电源，不仅仅是切换器，都可能包含设计不合需要的交流元件。&lt;/p&gt;
&lt;p&gt;使用 LDO 作为滤波器时应考虑的两个规格是电源抑制比 (PSRR) 和输出噪声。&lt;/p&gt;
&lt;h1 id=&#34;specifications&#34;&gt;Specifications&lt;/h1&gt;
&lt;p&gt;LDO 的特征在于其压差、静态电流、负载调节、线路调节、最大电流（由传输晶体管的大小决定）、速度（随着负载变化其响应速度）、电压变化由于负载电流、输出电容器及其等效串联电阻中的突然瞬变而导致输出中的问题。速度由输出电流的上升时间表示，因为它从 0 mA 负载电流（无负载）到最大负载电流。这基本上由误差放大器的带宽决定。还期望 LDO 在所有情况下提供安静和稳定的输出（可能的扰动示例可能是：输入电压或输出电流的突然变化）。稳定性分析采用了一些性能指标来获得这种行为，并涉及适当放置极点和​​零点。大多数情况下，在低频时会出现一个主导极点，而在高频时会推动其他极点和零点。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211029163501.jpg&#34; width=&#34;300px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;电源抑制比 Power supply rejection ratio&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PSRR 是指 LDO 抑制输入端纹波的能力。作为其调节的一部分，误差放大器和带隙会衰减输入电压中偏离与之比较的内部基准的任何尖峰。在理想的 LDO 中，输出电压将仅由直流频率组成。然而，误差放大器在高频下获得小尖峰的能力有限。PSRR 表示如下：&lt;/p&gt;
&lt;p&gt;$${\displaystyle {\text{PSRR}}={\frac {\Delta V_{\text{IN}}^{2}}{\Delta V_{\text{OUT}}^{2}}}=10\ log \left({\frac {\Delta V_{\text{IN}}^{2}}{\Delta V_{\text{OUT}}^{2}}}\right){\text{dB }}}$$&lt;/p&gt;
&lt;p&gt;例如，在 1 MHz 时 PSRR 为 55 dB 的 LDO 在此频率下将 1 mV 输入纹波衰减至输出端仅为 1.78 µV。PSRR 增加 6 dB 大致相当于衰减增加 2 倍。&lt;/p&gt;
&lt;p&gt;大多数 LDO 在较低频率 (10 Hz – 1 kHz) 下具有相对较高的 PSRR。然而，高性能 LDO 的特点是在很宽的频谱（10 Hz - 5 MHz）上具有高 PSRR。在宽带上具有高 PSRR 允许 LDO 抑制高频噪声，如开关产生的噪声。与其他规格类似，PSRR 会随着频率、温度、电流、输出电压和电压差而波动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出噪声 Output noise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在滤波器设计中还必须考虑来自 LDO 本身的噪声。与其他电子设备一样，LDO 受热噪声、双极散粒噪声和闪烁噪声的影响。 [9]这些现象中的每一种都会对输出电压产生噪声，主要集中在频谱的低端。为了正确过滤交流频率，LDO 必须抑制输入端的纹波，同时在输出端引入最小的噪声。如果有噪声的 LDO 只是在输出端再次增加该噪声，那么衰减输入电压纹波的努力可能会徒劳无功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载调节 Load regulation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负载调整率是衡量电路在不同负载条件下保持指定输出电压的能力。负载调节定义为：&lt;/p&gt;
&lt;p&gt;$${\displaystyle {\text{负载调节}}={\Delta V_{\text{OUT}} \over \Delta I_{\text{OUT}}}}$$&lt;/p&gt;
&lt;p&gt;输出电压变化的最坏情况发生在负载电流从零过渡到其最大额定值时，反之亦然。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线路调节 Line regulation&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线路调节是衡量电路在输入电压变化时保持指定输出电压的能力。线路调节定义为：&lt;/p&gt;
&lt;p&gt;$${\displaystyle {\text{线规}}={\Delta V_{\text{OUT}} \over \Delta V_{\text{IN}}}}$$&lt;/p&gt;
&lt;p&gt;与负载调整率一样，线路调整率是一个稳态参数——所有频率分量都被忽略。增加直流开环电流增益可改善线路调节。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;瞬态响应 Transient response&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;瞬态响应是负载电流阶跃变化的最大允许输出电压变化。瞬态响应是输出电容值 (${\textstyle C_{\text{OUT}}}$)、输出电容的等效串联电阻 (ESR)、旁路电容 (${\textstyle C_{\text{ BYP}}}$)，通常添加到输出电容器以改善负载瞬态响应和最大负载电流 (${\textstyle I_{\text{OUT,MAX}}}$)。最大瞬态电压变化定义如下：&lt;/p&gt;
&lt;p&gt;$${\displaystyle \Delta V_{\text{TR,MAX}}={\frac {I_{\text{OUT,MAX}}}{C_{\text{OUT}}+C_{\text{BYP}}} }\Delta t_{1}+{\Delta V_{\text{ESR}}}}$$&lt;/p&gt;
&lt;p&gt;其中 ${\textstyle \Delta t_{1}}$ 对应于 LDO 稳压器的闭环带宽。 ${\textstyle \Delta V_{\text{ESR}}}$ 是由于输出电容器的 ESR (${\textstyle R_{\text{ESR}}}$) 的存在而导致的电压变化。应用程序确定该值应该有多低。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Low-dropout_regulator&#34;&gt;Wikipedia-Low-dropout regulator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>I2S</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/28/i2s/</link>
      <pubDate>Thu, 28 Oct 2021 23:20:54 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/28/i2s/</guid>
      
      <description>&lt;p&gt;I2S（&lt;em&gt;&lt;strong&gt;Inter-IC Sound&lt;/strong&gt;&lt;/em&gt;）总线, 又称集成电路内置音频总线，是飞利浦半导体公司(现为恩智浦半导体公司)针对数字音频设备之间的音频数据传输而制定的一种总线标准。该总线专门用于音频设备之间的数据传输，广泛应用于各种多媒体系统。它采用了沿独立的导线传输时钟与数据信号的设计，通过将数据和时钟信号分离，避免了因时差诱发的失真，为用户节省了购买抵抗音频抖动的专业设备的费用。&lt;/p&gt;
&lt;h1 id=&#34;物理硬件层&#34;&gt;物理硬件层&lt;/h1&gt;
&lt;p&gt;I2S总线主要有3个信号线：&lt;/p&gt;
&lt;p&gt;(1).串行时钟SCK 串行时钟SCK，也叫位时钟BCLK，对应数字音频的每一位数据，SCK都有1个脉冲。&lt;strong&gt;SCK的频率 = 声道数 $*$&lt;/strong&gt; &lt;strong&gt;采样频率 $*$ 采样位数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;(2).字段选择信号WS 字段选择信号WS，也叫LRCLK，用于切换左右声道的数据。&lt;strong&gt;WS的频率 = 采样频率&lt;/strong&gt;。 字段选择信号WS表明了正在被传输的声道。I2S Philips标准WS信号的电平含义如下： WS为0，表示正在传输的是左声道的数据； WS为1，表示正在传输的是右声道的数据。&lt;/p&gt;
&lt;p&gt;(3).串行数据SD 串行数据SD，就是用二进制补码表示的音频数据。I2S串行数据在传输的时候，由高位(MSB)到低位(LSB)依次进行传输。&lt;/p&gt;
&lt;p&gt;(4).主时钟MCLK 一般还有MCLK，主时钟。&lt;strong&gt;MCLK的频率 = 128或者256或者512 $*$ 采样频率&lt;/strong&gt;。 对于系统而言，能够产生SCK和WS的信号端就是主设备，用MASTER表示，简单系统示意图如下&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/1572698569294149.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h1 id=&#34;软件协议层&#34;&gt;软件协议层&lt;/h1&gt;
&lt;p&gt;随着技术的发展，在统一的I2S硬件接口下，出现了多种不同的I2S数据格式，可分为左对齐(MSB)标准、右对齐(LSB)标准、I2S Philips 标准。 对于所有数据格式和通信标准而言，始终会先发送最高有效位(MSB 优先)。 发送端和接收端必须使用相同的数据格式，确保发送和接收的数据一致。&lt;/p&gt;
&lt;h2 id=&#34;i2s-philips-标准&#34;&gt;I2S Philips 标准&lt;/h2&gt;
&lt;p&gt;使用LRCLK信号来指示当前正在发送的数据所属的声道，为0时表示左声道数据。LRCLK信号从当前声道数据的第一个位(MSB)之前的一个时钟开始有效。LRCLK信号在BCLK的下降沿变化。发送方在时钟信号BCLK的下降沿改变数据，接收方在时钟信号BCLK的上升沿读取数据。正如上文所说，LRCLK频率等于采样频率Fs，一个LRCLK周期(1/Fs)包括发送左声道和右声道数据。&lt;/p&gt;
&lt;p&gt;对于这种标准I2S格式的信号，无论有多少位有效数据，数据的最高位总是出现在LRCLK变化（也就是一帧开始）后的第2个BCLK脉冲处。这就使得接收端与发送端的有效位数可以不同。如果接收端能处理的有效位数少于发送端，可以放弃数据帧中多余的低位数据；如果接收端能处理的有效位数多于发送端，可以自行补足剩余的位。这种同步机制使得数字音频设备的互连更加方便，而且不会造成数据错位。 I2S Philips 标准时序图如下所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/1572698570790276.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;左对齐msb标准&#34;&gt;左对齐(MSB)标准&lt;/h2&gt;
&lt;p&gt;在LRCLK发生翻转的同时开始传输数据。该标准较少使用。注意此时LRCLK为1时，传输的是左声道数据，这刚好与I2S Philips标准相反。左对齐(MSB)标准时序图如下所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/1572698574242057.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;右对齐lsb标准&#34;&gt;右对齐(LSB)标准&lt;/h2&gt;
&lt;p&gt;声音数据LSB传输完成的同时，LRCLK完成第二次翻转（刚好是LSB和LRCLK是右对齐的，所以称为右对齐标准）。注意此时LRCLK为1时，传输的是左声道数据，这刚好与I2S Philips标准相反。右对齐(LSB)标准时序图如下所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/1572698573117756.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;http://www.only2fire.com/archives/108.html&#34;&gt;I2S协议&lt;/a&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>I2C</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/28/i2c/</link>
      <pubDate>Thu, 28 Oct 2021 23:12:31 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/28/i2c/</guid>
      
      <description>&lt;p&gt;I2C 通讯协议（&lt;em&gt;&lt;strong&gt;Inter-Integrated Circuit&lt;/strong&gt;&lt;/em&gt;）是由 Phiilps 公司开发的，由于它引脚少，硬件实现简单，可扩展性强，不需要 USART、CAN 等通讯协议的外部收发设备，现在被广泛地使用在系统内多个集成电路(IC)间的通讯。&lt;/p&gt;
&lt;p&gt;在计算机科学里，大部分复杂的问题都可以通过分层来简化。如芯片被分为内核层和片上外设；STM32 标准库则是在寄存器与用户代码之间的软件层。对于通讯协议，我们也以分层的方式来理解，最基本的是把它分为物理层和协议层。物理层规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。协议层主要规定通讯逻辑，统一收发双方的数据打包、解包标准。&lt;/p&gt;
&lt;h1 id=&#34;物理层硬件拓扑&#34;&gt;物理层硬件拓扑&lt;/h1&gt;
&lt;p&gt;它的物理层有如下特点：&lt;/p&gt;
&lt;p&gt;(1) 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。&lt;/p&gt;
&lt;p&gt;(2) 一个 I2C 总线只使用两条总线线路，一条双向串行数据线(SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。&lt;/p&gt;
&lt;p&gt;(3) 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。&lt;/p&gt;
&lt;p&gt;(4) 总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。&lt;/p&gt;
&lt;p&gt;(5) 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。&lt;/p&gt;
&lt;p&gt;(6) 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I 2C 设备尚不支持高速模式。&lt;/p&gt;
&lt;p&gt;(7) 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制 。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20201219113846689.png&#34; width=&#34;300px&#34; /&gt;
&lt;/div&gt;
&lt;h1 id=&#34;软件协议层&#34;&gt;软件协议层&lt;/h1&gt;
&lt;h2 id=&#34;i2c-基本读写过程&#34;&gt;I2C 基本读写过程&lt;/h2&gt;
&lt;p&gt;I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20180503110807692.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20180503110808764.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;其中 S 表示由主机的 I2C 接口产生的传输起始信号(S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。&lt;/p&gt;
&lt;p&gt;起始信号产生后，所有从机就开始等待主机紧接下来 广播 的从机地址信号 (SLAVE_ADDRESS)。在 I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7 位或 10 位。&lt;/p&gt;
&lt;p&gt;在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。&lt;/p&gt;
&lt;p&gt;从机接收到匹配的地址后，主机或从机会返回一个应答(ACK)或非应答(NACK)信号，只有接收到应答信号后，主机才能继续发送或接收数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若配置的方向传输位为“写数据”方向，即第一幅图的情况，广播完地址，接收到应答信号后，主机开始正式向从机传输数据(DATA)，数据包的大小为 8 位，主机每发送完一个字节数据，都要等待从机的应答信号(ACK)，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号(P)，表示不再传输数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;若配置的方向传输位为“读数据”方向，即第二幅图的情况，广播完地址，接收到应答信号后，从机开始向主机返回数据(DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号(ACK)，重复这个过程，可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号(NACK)，则从机自动停止数据传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读和写数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了基本的读写，I2C 通讯更常用的是复合格式，即第三幅图的情况，该传输过程有两次起始信号(S)。一般在第一次传输中，主机通 SLAVE_ADDRESS 寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址(注意区分它与 SLAVE_ADDRESS 的区别)；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。&lt;/p&gt;
&lt;p&gt;以上通讯流程中包含的各个信号分解如下：&lt;/p&gt;
&lt;h2 id=&#34;通讯的起始和停止信号&#34;&gt;通讯的起始和停止信号&lt;/h2&gt;
&lt;p&gt;前文中提到的起始(S)和停止(P)信号是两种特殊的状态，如图。当 SCL 线是高电平时 SDA 线从高电平向低电平切换，这个情况表示通讯的起始。当 SCL 是高电平时 SDA 线由低电平向高电平切换，表示通讯的停止。起始和停止信号一般由主机产生。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20180503110809562.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;数据有效性&#34;&gt;数据有效性&lt;/h2&gt;
&lt;p&gt;I2C 使用 SDA 信号线来传输数据，使用 SCL 信号线进行数据同步。如图，SDA 数据线在 SCL 的每个时钟周期传输一位数据。传输时，SCL 为高电平的时候 SDA 表示的数据有效，即此时的 SDA 为高电平时表示数据“1”，为低电平时表示数据“0”。当 SCL 为低电平时，SDA 的数据无效，一般在这个时候 SDA 进行电平切换，为下一次表示数据做好准备。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20180503110810884.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;地址及数据方向&#34;&gt;地址及数据方向&lt;/h2&gt;
&lt;p&gt;I2C 总线上的每个设备都有自己的独立地址，主机发起通讯时，通过 SDA 信号线发送设备地址(SLAVE_ADDRESS)来查找从机。I2C 协议规定设备地址可以是 7 位或 10 位，实际中 7 位的地址应用比较广泛。紧跟设备地址的一个数据位用来表示数据传输方向，它是数据方向位(R/W —— )，第 8 位或第 11 位。数据方向位为“1”时表示主机由从机读数据，该位为“0”时表示主机向从机写数据。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20180503110811781.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;响应&#34;&gt;响应&lt;/h2&gt;
&lt;p&gt;I2C 的数据和地址传输都带响应。响应包括“应答(ACK)”和“非应答(NACK)”两种信号。作为数据接收端时，当设备(无论主从机)接收到 I2C 传输的一个字节数据或地址后，若希望对方继续发送数据，则需要向对方发送“应答(ACK)”信号，发送方会继续发送下一个数据；若接收端希望结束数据传输，则向对方发送“非应答(NACK)”信号，发送方接收到该信号后会产生一个停止信号，结束信号传输，如图。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20180503110812845.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h1 id=&#34;软件-i2c-和硬件-i2c&#34;&gt;软件 I2C 和硬件 I2C&lt;/h1&gt;
&lt;p&gt;想要控制 STM32 产生 I2C 方式的通讯，可以采用软件模拟或硬件 I2C 这两种方式。&lt;/p&gt;
&lt;p&gt;所谓软件模拟，即直接使用 CPU 内核按照 I2C 协议的要求控制 GPIO 输出高低电平。如控制产生 I2C 的起始信号时，见图 24-5，先控制作为 SCL 线的 GPIO 引脚输出高电平，然后控制作为 SDA 线的 GPIO 引脚在此期间完成由高电平至低电平的切换，最后再控制 SCL 线切换为低电平，这样就输出了一个标准的 I2C 起始信号。&lt;/p&gt;
&lt;p&gt;而硬件 I2C 是指直接利用 STM32 芯片中的硬件 I2C 外设，该硬件 I2C 外设跟 USART 串口外设类似，只要配置好对应的寄存器，外设就会产生标准串口协议的时序。使用它的 I2C 外设则可以方便地通过外设寄存器产生 I2C 协议方式的通讯，如初始化好 I2C 外设后，只需要把某寄存器位置 1，那么外设就会控制对应的 SCL 及 SDA 线自动产生 I2C 起始信号，而不需要内核直接控制引脚的电平。&lt;/p&gt;
&lt;p&gt;相对来说，硬件 I2C 直接使用外设来控制引脚，可以减轻 CPU 的负担。不过使用硬件 I2C 时必须使用某些固定的引脚作为 SCL 和 SDA，软件模拟 I2C 则可以使用任意 GPIO 引脚，相对比较灵活。在本开发板中，由于 STM32RCT6 芯片引脚较少，资源比较紧张，在设计硬件时不方便使用硬件 I2C 指定的引脚连接外部设备（EEPROM 存储器芯片），所以在控制程序上只能使用软件模拟 I2C 的方式。&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>SPI</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/28/spi/</link>
      <pubDate>Thu, 28 Oct 2021 22:58:28 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/28/spi/</guid>
      
      <description>&lt;p&gt;SPI（&lt;em&gt;&lt;strong&gt;Serial Peripheral Interface&lt;/strong&gt;&lt;/em&gt;）总线是主要应用于嵌入式系统内部通信的串行同步传输总线协议。通常为&lt;strong&gt;四线制&lt;/strong&gt;的SPI总线支持&lt;strong&gt;全双工通信&lt;/strong&gt;。SPI最初由Motorola在2000年提出，Motorola所定义的SPI标准为业界广泛引用，但不同半导体公司的实施细节可能有所不同，这些区别体现在寄存器设置、信号定义、数据格式等。业界没有统一的SPI标准，具体应用需要参考特定器件手册。&lt;/p&gt;
&lt;p&gt;SPI协议特点包括主从模式、全双工通信、片选功能、模式错误标识及CPU中断、缓冲数据寄存器和可配置时钟相位极性等。SPI允许数据一位一位的传送，甚至允许暂停，因为SCK时钟线由主控设备控制，当没有时钟跳变时，从设备不采集或传送数据。也就是说，主设备通过对SCK时钟线的控制可以完成对通讯的控制。&lt;/p&gt;
&lt;h1 id=&#34;物理层硬件拓扑&#34;&gt;物理层硬件拓扑&lt;/h1&gt;
&lt;p&gt;SPI总线定义两个及以上设备间的数据传输，提供时钟的设备为主设备（Master），接收时钟的设备为从设备（Slave）。&lt;/p&gt;
&lt;p&gt;SPI协议定义四根信号线，分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SCK&lt;/strong&gt; : Serial Clock 串行时钟&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;时钟信号线，用于通讯数据同步。它由通讯主机产生，决定了通讯的速率，不同的设备支持的最高时钟频率不一样，如 STM32 的 SPI 时钟频率最大为fpclk/2，两个设备之间通讯时，通讯速率受限于低速设备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MOSI&lt;/strong&gt; : Master Output, Slave Input 主发从收信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主设备输出/从设备输入引脚。主机的数据从这条信号线输出，从机由这条信号线读入主机发送的数据，即这条线上数据的方向为主机到从机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MISO&lt;/strong&gt; : Master Input, Slave Output 主收从发信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;主设备输入/从设备输出引脚。主机从这条信号线读入数据，从机的数据由这条信号线输出到主机，即在这条线上数据的方向为从机到主机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SS&lt;/strong&gt; : Slave Select 片选信号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从设备选择信号线，常称为片选信号线，也称为 NSS、 CS，以下用 NSS 表示。 当有多个 SPI 从设备与 SPI 主机相连时，设备的其它信号线 SCK、MOSI 及 MISO 同时并联到相同的 SPI 总线上，即无论有多少个从设备，都共同只使用这 3 条总线；而每个从设备都有独立的这一条 NSS 信号线，本信号线独占主机的一个引脚，即有多少个从设备，就有多少条片选信号线。 I2C 协议中通过设备地址来寻址、选中总线上的某个设备并与其进行通讯；而 SPI 协议中没有设备地址，它使用 NSS 信号线来寻址，当主机要选择从设备时，把该从设备的 NSS 信号线设置为低电平，该从设备即被选中，即片选有效，接着主机开始与被选中的从设备进行 SPI 通讯。所以SPI 通讯以 NSS 线置低电平为开始信号，以 NSS 线被拉高作为结束信号。&lt;/p&gt;
&lt;p&gt;其中MISO方向为从设备到主设备，其余三个信号均为主设备到从设备。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于主设备，如果设置SS作为从设备的片选信号（最常用的场合），则它就不能用于多主设备应用的模式错误检测（参考SSOE和MODFEN寄存器设置，表1）&lt;/li&gt;
&lt;li&gt;SPI单个数据管脚支持双向模式。在双向模式下，主设备的MOSI，从设备的MISO作为双向IO&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图表示基本的SPI设备连接示意图。片选信号SS通常低电平有效。SPI数据传输原理是基于主从设备内部&lt;strong&gt;移位寄存器&lt;/strong&gt;的数据交换。在主设备SCK的控制下，待传数据由各自设备的&lt;strong&gt;数据寄存器&lt;/strong&gt;（Data Register）传输到&lt;strong&gt;移位寄存器&lt;/strong&gt;（Shift Register），再通过MOSI和MISO信号线完成主从设备间的数据交换。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211027084101.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;主从设备间数据交换逻辑示意图如下图所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211027084301.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;单个主设备和单个从设备的SPI连接比较简单，以上图表示的就是这种拓扑结构。&lt;br&gt;
通过多个片选信号（SS）或菊花链方式（Daisy Chain Configuration），单个主设备可以同时控制多个不同从设备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;片选方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图4示，每个从设备都需要单独的片选信号，主设备每次只能选择其中一个从设备进行通信。因为所有从设备的SCK、MOSI、MISO都是连在一起的，未被选中从设备的MISO要表现为高阻状态（Hi-Z）以避免数据传输错误。由于每个设备都需要单独的片选信号，如果需要的片选信号过多，可以使用&lt;strong&gt;译码器&lt;/strong&gt;产生所有的片选信号。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211027084701.png&#34; width=&#34;400px&#34; /&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;菊花链方式&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如图示，数据信号经过主从设备所有的移位寄存器构成闭环。数据通过主设备&lt;strong&gt;发送&lt;/strong&gt;（绿色线）经过从设备&lt;strong&gt;返回&lt;/strong&gt;（蓝色线）到主设备。在这种方式下，片选和时钟同时接到所有从设备，通常用于移位寄存器和LED驱动器。注意，菊花链方式的主设备需要发送&lt;strong&gt;足够长的数据&lt;/strong&gt;以确保数据送达到所有从设备。切记主设备所发送的第一个数据需（移位）到达菊花链中最后一个从设备。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211027084601.png&#34; width=&#34;400px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;菊花链式连接常用于仅需主设备发送数据而不需要接收返回数据的场合，如 LED驱动器。在这种应用下，主设备MISO可以不连。如果需要接收从设备的返回数据，则需要连接主设备的MISO形成闭环。同样地，切记要发送足够多的接收指令以确保数据（移位）送达主设备。&lt;/p&gt;
&lt;h1 id=&#34;软件协议层&#34;&gt;软件协议层&lt;/h1&gt;
&lt;p&gt;这是一个主机的通讯时序。 NSS、 SCK、 MOSI 信号都由主机控制产生，而 MISO 的信号由从机产生，主机通过该信号线读取从机的数据。 MOSI 与 MISO 的信号只在 NSS 为低电平的时候才有效，在 SCK 的每个时钟周期 MOSI 和 MISO 传输一位数据。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20191103203850207.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;以上通讯流程中包含的各个信号分解如下：&lt;/p&gt;
&lt;h2 id=&#34;通讯的起始停止信号&#34;&gt;通讯的起始/停止信号&lt;/h2&gt;
&lt;p&gt;在图 25-2 中的标号处， NSS 信号线由高变低，是 SPI 通讯的起始信号。 NSS 是每个从机各自独占的信号线，当从机在自己的 NSS 线检测到起始信号后，就知道自己被主机选中了，开始准备与主机通讯。在图中的标号处， NSS 信号由低变高，是 SPI 通讯的停止信号，表示本次通讯结束，从机的选中状态被取消。&lt;/p&gt;
&lt;h2 id=&#34;数据有效性&#34;&gt;数据有效性&lt;/h2&gt;
&lt;p&gt;SPI 使用 MOSI 及 MISO 信号线来传输数据，使用 SCK 信号线进行数据同步。 MOSI及 MISO 数据线在 SCK 的每个时钟周期传输一位数据，且数据输入输出是同时进行的。数据传输时， MSB 先行或 LSB 先行并没有作硬性规定，但要保证两个 SPI 通讯设备之间使用同样的协定，一般都会采用图 25-2 中的 MSB 先行模式。观察图中的标号处， MOSI 及 MISO 的数据在 SCK 的上升沿期间变化输出，在 SCK 的下降沿时被采样。即在 SCK 的下降沿时刻， MOSI 及 MISO 的数据有效，高电平时表示数据“1”，为低电平时表示数据“0”。在其它时刻，数据无效， MOSI 及 MISO为下一次表示数据做准备。
SPI 每次数据传输可以 8 位或 16 位为单位，每次传输的单位数不受限制。&lt;/p&gt;
&lt;h2 id=&#34;cpolcpha&#34;&gt;CPOL/CPHA&lt;/h2&gt;
&lt;p&gt;上面讲述的图 25-2 中的时序只是 SPI 中的其中一种通讯模式， SPI 一共有四种通讯模式，它们的主要区别是总线空闲时 SCK 的时钟状态以及数据采样时刻。为方便说明，在此引入“时钟极性 CPOL”和“时钟相位 CPHA”的概念。时钟极性 CPOL 是指 SPI 通讯设备处于空闲状态时， SCK 信号线的电平信号(即 SPI 通讯开始前、 NSS 线为高电平时 SCK 的状态)。 CPOL=0 时， SCK 在空闲状态时为低电平，CPOL=1 时，则相反。时钟相位 CPHA 是指数据的采样的时刻，当 CPHA=0 时， MOSI 或 MISO 数据线上的信号将会在 SCK 时钟线的“奇数边沿” 被采样。当 CPHA=1 时，数据线在 SCK 的“偶数边沿” 采样。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20191103204134232.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;我们来分析这个 CPHA=0 的时序图。首先，根据 SCK 在空闲状态时的电平，分为两种情况。 SCK 信号线在空闲状态为低电平时， CPOL=0；空闲状态为高电平时， CPOL=1。无论 CPOL=0 还是=1，因为我们配置的时钟相位 CPHA=0，在图中可以看到， 采样时刻都是在 SCK 的奇数边沿。注意当 CPOL=0 的时候，时钟的奇数边沿是上升沿，而CPOL=1 的时候，时钟的奇数边沿是下降沿。所以 SPI 的采样时刻不是由上升/下降沿决定的。 MOSI 和 MISO 数据线的有效信号在 SCK 的奇数边沿保持不变，数据信号将在 SCK 奇数边沿时被采样，在非采样时刻， MOSI 和 MISO 的有效信号才发生切换。类似地，当 CPHA=1 时，不受 CPOL 的影响，数据信号在 SCK 的偶数边沿被采样。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/2019110320422689.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;由 CPOL 及 CPHA 的不同状态， SPI 分成了四种模式，见表 25-1，主机与从机需要工作在相同的模式下才可以正常通讯，实际中采用较多的是“模式 0”与“模式 3”。&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;SPI 模式&lt;/th&gt;
&lt;th&gt;CPOL&lt;/th&gt;
&lt;th&gt;CPHA&lt;/th&gt;
&lt;th&gt;空闲时 SCK 时钟&lt;/th&gt;
&lt;th&gt;采样时刻&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;低电平&lt;/td&gt;
&lt;td&gt;奇数边沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;低电平&lt;/td&gt;
&lt;td&gt;偶数边沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;高电平&lt;/td&gt;
&lt;td&gt;奇数边沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;高电平&lt;/td&gt;
&lt;td&gt;偶数边沿&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/monkea123/article/details/102886525&#34;&gt;SPI总线-物理层 协议层&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>UART</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/28/uart/</link>
      <pubDate>Thu, 28 Oct 2021 22:34:38 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/28/uart/</guid>
      
      <description>&lt;p&gt;UART 通用异步收发传输器（Universal Asynchronous Receiver/Transmitter），通常称作 UART，是一种通用的串行异步全双工数据收发传输器（总线）。&lt;/p&gt;
&lt;p&gt;UART的作用是：把“要传输的数据”在串行通信与并行通信之间转换。在嵌入式领域，作为把并行信号转成串行信号的硬件设备，UART通常被集成于MCU内部。&lt;/p&gt;
&lt;h1 id=&#34;物理硬件层&#34;&gt;物理硬件层&lt;/h1&gt;
&lt;p&gt;硬件连接比较简单，仅需要3条线，注意连接时两个设备UART电平，如电平范围不一致请做电平转换后再连接，如下图所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211027152006.png&#34; width=&#34;300px&#34; /&gt;
&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;TX：发送数据端，要接对面设备的RX&lt;/li&gt;
&lt;li&gt;RX：接收数据端，要接对面设备的TX&lt;/li&gt;
&lt;li&gt;GND：保证两设备共地，有统一的参考平面&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;软件协议层&#34;&gt;软件协议层&lt;/h1&gt;
&lt;p&gt;UART作为异步串行通信协议的一种，工作原理是将传输数据的每个二进制位一位接一位地传输。在UART通信协议中信号线上的状态为高电平时代表‘1’，信号线上的状态为低电平时代表‘0’。比如使用UART通信协议进行一个字节数据的传输时就是在信号线上产生八个高低电平的组合。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;串行通信是指利用一条传输线将数据一位位地顺序传送，也可以用两个信号线组成全双工通信，如rs232。特点是通信线路简单，利用简单的线缆就可实现通信，降低成本，适用于远距离通信，但传输速度慢的应用场合。&lt;/li&gt;
&lt;li&gt;异步通信以一个字符为传输单位，通信中两个字符间的时间间隔多少是不固定的，然而在同一个字符中的两个相邻位间的时间间隔是固定的。通俗说是两个uart设备之间通信的时候不需要时钟线，这时候就需要在两个uart设备上指定相同的传输速率，以及空闲位、起始位、校验位、结束位，也就是遵循相同的协议。&lt;/li&gt;
&lt;li&gt;数据传送速率用波特率来表示，即每秒钟传送的二进制位数。例如数据传送速率为120字符/秒，而每一个字符为10位（1个起始位，7个数据位，1个校验位，1个结束位），则其传送的波特率为10×120＝1200字符/秒＝1200波特。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据通信格式如下图：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211027151401.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;其中各位的意义如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空闲位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　UART协议规定，当总线处于空闲状态时信号线的状态为‘1’即高电平，表示当前线路上没有数据传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;起始位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　每开始一次通信时发送方先发出一个逻辑”0”的信号（低电平），表示传输字符的开始。因为总线空闲时为高电平所以开始一次通信时先发送一个明显区别于空闲状态的信号即低电平。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　起始位之后就是我们所要传输的数据，数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。如ASCII码（7位），扩展BCD码（8位）。先发送&lt;strong&gt;最低位&lt;/strong&gt;，最后发送&lt;strong&gt;最高位&lt;/strong&gt;，使用低电平表示‘0’高电平表示‘1’完成数据位的传输。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;奇偶校验位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。校验位其实是调整个数，串口校验分几种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、无校验（no parity）。&lt;/li&gt;
&lt;li&gt;2、奇校验（odd parity）：如果数据位中“1”的数目是偶数，则校验位为“1”，如果“1”的数目是奇数，校验位为“0”。&lt;/li&gt;
&lt;li&gt;3、偶校验（even parity）：如果数据为中“1”的数目是偶数，则校验位为“0”，如果为奇数，校验位为“1”。&lt;/li&gt;
&lt;li&gt;4、mark parity：校验位始终为1（不常用）。&lt;/li&gt;
&lt;li&gt;5、parity：校验位始终为0（不常用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;停止位：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。 由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备之间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟的机会。停止位个数越多，数据传输越稳定，但是数据传输速度也越慢。&lt;/p&gt;
&lt;h1 id=&#34;波特率&#34;&gt;波特率&lt;/h1&gt;
&lt;p&gt;数据传输速率使用波特率来表示。单位bps（bits per second），常见的波特率9600bps、115200bps等等，其他标准的波特率是1200，2400，4800，19200，38400，57600。举个例子，如果串口波特率设置为9600bps，那么传输一个比特需要的时间是1/9600≈104.2us。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202110271516.jpg&#34; width=&#34;300px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;以9600，8-N-1（9600波特率，8个数据位，没有校验位，1位停止位）为例，这是目前最常用的串口配置，现在我们传输“O”“K”两个ASCII值，“O”的ASCII为79，对应的二进制数据为&lt;strong&gt;01001111&lt;/strong&gt;，“K”对应的二进制数据为&lt;strong&gt;01001011&lt;/strong&gt;，传输的格式数据如下图所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202110271517.jpg&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/150504364&#34;&gt;UART串口协议详解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>Introduction to Communication Protocol</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/28/introduction-to-communication-protocol/</link>
      <pubDate>Thu, 28 Oct 2021 17:01:24 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/28/introduction-to-communication-protocol/</guid>
      
      <description>&lt;h2 id=&#34;通讯的基本概念&#34;&gt;通讯的基本概念&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;串行通讯和并行通讯&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;串行通讯&lt;/th&gt;
&lt;th&gt;并行通讯&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;通讯距离&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较远&lt;/td&gt;
&lt;td&gt;较近&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;抗干扰能力&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较强&lt;/td&gt;
&lt;td&gt;较弱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;传输速率&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较慢&lt;/td&gt;
&lt;td&gt;较高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;成本&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;较低&lt;/td&gt;
&lt;td&gt;较高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;全双工、半双工及单工通讯&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通讯方式&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;全双工&lt;/td&gt;
&lt;td&gt;在同一时刻，两个设备之间可以同时收发数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;半双工&lt;/td&gt;
&lt;td&gt;两个设备之间可以收发数据，但不能在同一时刻进行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单工&lt;/td&gt;
&lt;td&gt;在任何时刻都只能进行一个方向的通讯，即一个固定为发送设备，另一个固定为接收设备&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;同步通讯与异步通讯&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在同步通讯中，收发设备双方会&lt;strong&gt;使用一根信号线表示时钟信号&lt;/strong&gt;，在时钟信号的驱动下双方进行协调，同步数据。通讯中通常双方会统一规定在时钟信号的&lt;strong&gt;上升沿或下降沿&lt;/strong&gt;对数据线进行采样。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506026747.png&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;在异步通讯中&lt;strong&gt;不使用时钟信号&lt;/strong&gt;进行数据同步，它们直接在数据信号中穿插一些同步用的信号位，或者把主体数据进行打包，以&lt;strong&gt;数据帧&lt;/strong&gt;的格式传输数据。某些通讯中还需要双方约定数据的传输速率，以便更好地同步。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506032390.jpg&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;在同步通讯中，数据信号所传输的内容绝大部分就是有效数据，而异步通讯中会包含有帧的各种标识符，所以&lt;strong&gt;同步通讯的效率更高&lt;/strong&gt;，但是同步通讯双方的时钟允许误差较小，而异步通讯双方的时钟允许误差较大。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通讯速率&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Bitrate—比特率&lt;/strong&gt;：每秒钟传输的二进制位数，单位为比特每秒(bit/s) 。（I2C、SPI）（同步）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Baudrate—波特率&lt;/strong&gt;：表示每秒钟传输的码元个数。（USART）（异步）&lt;/p&gt;
&lt;p&gt;一般一个码元用一个二进制表示，如：0V-0，3.3V-1&lt;/p&gt;
&lt;p&gt;但是当码元有多个时，需要多位的二进制表示，如：0V-00，2V-01，4V-10，6V-11&lt;/p&gt;
&lt;h2 id=&#34;串口通讯协议简介&#34;&gt;串口通讯协议简介&lt;/h2&gt;
&lt;p&gt;对于通讯协议，&lt;strong&gt;我们以分层的方式来理解&lt;/strong&gt;，分为物理层和协议层。&lt;/p&gt;
&lt;h3 id=&#34;物理层&#34;&gt;物理层&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;物理层：&lt;/strong&gt; 规定通讯系统中具有机械、电子功能部分的特性，确保原始数据在物理媒体的传输。（硬件）&lt;/p&gt;
&lt;h4 id=&#34;rs-232&#34;&gt;RS-232&lt;/h4&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506049730.jpg&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;RS232标准串口主要用于工业设备直接通信&lt;/li&gt;
&lt;li&gt;电平转换芯片一般有 MAX3232，SP3232&lt;/li&gt;
&lt;li&gt;DB9接口（COM口） 标准的公头及母头接法&lt;/li&gt;
&lt;/ol&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506045687.jpg&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h4 id=&#34;usb转串口&#34;&gt;USB转串口&lt;/h4&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506054588.jpg&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;USB转串口主要用于设备跟电脑通信&lt;/li&gt;
&lt;li&gt;电平转换芯片一般有CH340、PL2303、CP2102、FT232&lt;/li&gt;
&lt;li&gt;使用的时候电脑端需要安装电平转换芯片的驱动&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;原生的串口到串口&#34;&gt;原生的串口到串口&lt;/h4&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506056001.jpg&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;原生的串口通信主要是控制器跟串口的设备或者传感器通信，不需要经过电平转换芯片来转换电平，直接就用TTL电平通信&lt;/li&gt;
&lt;li&gt;GPS模块、GSM模块、串口转WIFI模块、HC04蓝牙模块&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;ttl和232的区别&#34;&gt;TTL和232的区别&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;电平标准不同&lt;/strong&gt;：TTL电平一般是芯片里面出来的电平&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通讯标准&lt;/th&gt;
&lt;th&gt;电平标准（发送端）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;5V TTL&lt;/td&gt;
&lt;td&gt;逻辑1：2.4V ~ 5V； 逻辑0：0 ~ 0.5V&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RS-232&lt;/td&gt;
&lt;td&gt;逻辑1：-15V ~ -3V ；逻辑0：+3V ~ +15V（增加抗干扰能力）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506066159.jpg&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h3 id=&#34;协议层&#34;&gt;协议层&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;协议层：&lt;/strong&gt; 主要规定通讯逻辑，统一收发双方的数据打包、解包标准。（软件）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;串口数据包的基本组成&lt;/strong&gt;&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/202008241506063872.jpg&#34; width=&#34;600px&#34; /&gt;
&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;波特率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本章中主要讲解的是串口异步通讯，异步通讯中由于没有时钟信号(如前面讲解的DB9接口中是没有时钟信号的)，所&lt;strong&gt;以两个通讯设备之间需要约定好波特率，即每个码元的长度&lt;/strong&gt;，以便对信号进行解码。上图中用&lt;strong&gt;虚线分开的每一格就是代表一个码元&lt;/strong&gt;。常见的波特率为4800、9600、115200 等。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;通讯的起始和停止信号&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数据包的起始信号由一个&lt;strong&gt;逻辑0&lt;/strong&gt; 的数据位表示，而数据包的停止信号可由&lt;strong&gt;0.5、1、1.5 或2 个逻辑1&lt;/strong&gt; 的数据位表示，只要双方约定一致即可。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;有效数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在数据包的起始位之后紧接着的就是&lt;strong&gt;要传输的主体数据内容&lt;/strong&gt;，也称为有效数据，有效数据的长度常被约定为5、6、7 或8 位长。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;数据校验（可选）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于数据通信相对更容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。校验方法有&lt;strong&gt;奇校验(odd)、偶校验(even)、0 校验(space)、1 校验(mark)以及无校验(noparity)。&lt;/strong&gt;&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>MCS 51 Basics (3)</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/25/mcs-51-basics-3/</link>
      <pubDate>Mon, 25 Oct 2021 22:59:29 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/25/mcs-51-basics-3/</guid>
      
      <description>&lt;h1 id=&#34;独立按键&#34;&gt;独立按键&lt;/h1&gt;
&lt;p&gt;前面介绍的都是 IO 口输出的使用，这一章我们通过独立按键实验来介绍 IO 口作为输入的使用。开发板上板载 4 个独立按键。我们所要实现的功能是：通过开发板上的独立按键 K1 控制 D1 指示灯亮灭。&lt;/p&gt;
&lt;h2 id=&#34;按键介绍&#34;&gt;按键介绍&lt;/h2&gt;
&lt;p&gt;按键是一种电子开关，使用时轻轻按开关按钮就可使开关接通，当松开手时, 开关断开。开发板上使用的按键及内部简易图如下图所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211025230539.png&#34; width=&#34;300px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;按键管脚两端距离长的表示默认是导通状态，距离短的默认是断开状态，如果按键按下，初始导通状态变为断开，初始断开状态变为导通。通常的按键所用开关为机械弹性开关，当机械触点断开、闭合时，电压信号如下图所示：&lt;/p&gt;
&lt;p&gt;由于机械点的弹性作用，按键开关在闭合时不会马上稳定的接通，在断开时也不会一下子断开，因而在闭合和断开的瞬间均伴随着一连串的抖动。抖动时间的长短由按键的机械特性决定的，一般为 5ms 到 10ms。按键稳定闭合时间的长短则由操作人员的按键动作决定的，一般为零点几秒至数秒。按键抖动会引起按键被误读多次。为了确保 CPU 对按键的一次闭合仅作一次处理，必须进行消抖。按键消抖有两种方式，一种是&lt;strong&gt;硬件消抖&lt;/strong&gt;，另一种是&lt;strong&gt;软件消抖&lt;/strong&gt;。为了使电路更加简单，通常采用软件消抖。我们开发板也是采用软件消抖，一般来说一个简单的按键消抖就是先读取按键的状态，如果得到按键按下之后，延时 10ms，再次读取按键的状态，如果按键还是按下状态，那么说明按键已经按下。其中延时 10ms 就是软件消抖处理，至于硬件消抖，网上都有非常详细的介绍。
这里给大家列出单片机常用的软件去抖动方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先设置 IO 口为高电平（由于开发板 IO 都有上拉电阻，所以默认 IO 为高电平）。&lt;/li&gt;
&lt;li&gt;读取 IO 口电平确认是否有按键按下。&lt;/li&gt;
&lt;li&gt;如有 IO 电平为低电平后，延时几个毫秒。&lt;/li&gt;
&lt;li&gt;再读取该 IO 电平，如果仍然为低电平，说明按键按下。&lt;/li&gt;
&lt;li&gt;执行按键控制程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;独立按键电路构成是由各个按键的一个管脚连接在一起接地，按键其他引脚分别接到单片机 IO 口。&lt;/p&gt;
&lt;p&gt;我们知道单片机的 IO 口既可作为输出也可作为输入使用，当检测按键时用的是它的输入功能，独立按键的一端接地，另一端与单片机的 I/O 口相连，开始时先给该 IO 口赋一高电平，然后让单片机不断地检测该 I/O 口是否变为低电平，当按键闭合时，即相当于该 I/O 口通过按键与地相连，变成低电平，程序一旦检测到 I/O 口变为低电平则说明按键被按下，然后执行相应的指令。&lt;/p&gt;
&lt;h2 id=&#34;hardware-design&#34;&gt;Hardware Design&lt;/h2&gt;
&lt;h2 id=&#34;software-design&#34;&gt;Software Design&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;reg52.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u16;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//对系统默认数据类型进行重定义
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; u8;

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//定义独立按键控制脚
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;sbit KEY1&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P3&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;
sbit KEY2&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P3&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
sbit KEY3&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P3&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;
sbit KEY4&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P3&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;;

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//定义LED1控制脚
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;sbit LED1&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P2&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//使用宏定义独立按键按下的键值
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define KEY1_PRESS    1
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define KEY2_PRESS    2
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define KEY3_PRESS    3
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define KEY4_PRESS    4
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#define KEY_UNPRESS    0    
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;delay_10us&lt;/span&gt;(u16 ten_us)
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(ten_us&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;);    
}

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/***********************************************************
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 函 数 名       : key_scan
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 函数功能         : 检测独立按键是否按下，按下则返回对应键值
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 输    入       : mode=0：单次扫描按键
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                   mode=1：连续扫描按键
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 输    出         : KEY1_PRESS：K1按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                   KEY2_PRESS：K2按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                   KEY3_PRESS：K3按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                   KEY4_PRESS：K4按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;                   KEY_UNPRESS：未有按键按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;************************************************************/&lt;/span&gt;
u8 &lt;span style=&#34;color:#00a000&#34;&gt;key_scan&lt;/span&gt;(u8 mode)
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;static&lt;/span&gt; u8 key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;

    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(mode)key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//连续扫描按键
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(key&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;(KEY1&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt;KEY2&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt;KEY3&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;||&lt;/span&gt;KEY4&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;))&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//任意按键按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    {
        delay_10us(&lt;span style=&#34;color:#666&#34;&gt;1000&lt;/span&gt;);&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//消抖
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(KEY1&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; KEY1_PRESS;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(KEY2&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; KEY2_PRESS;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(KEY3&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; KEY3_PRESS;
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(KEY4&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; KEY4_PRESS;    
    }
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(KEY1&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;KEY2&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;KEY3&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;KEY4&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//无按键按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    {
        key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;            
    }
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; KEY_UNPRESS;        
}

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
{    
    u8 key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;

    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
    {
        key&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;key_scan(&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(key&lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt;KEY1_PRESS)&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//检测按键K1是否按下
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;            LED1&lt;span style=&#34;color:#666&#34;&gt;=!&lt;/span&gt;LED1;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//LED1状态翻转    
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    }        
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
      
    </item>
    
    <item>
      <title>MCS 51 Basics (2)</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/24/mcs-51-basics-2/</link>
      <pubDate>Sun, 24 Oct 2021 22:18:50 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/24/mcs-51-basics-2/</guid>
      
      <description>&lt;h1 id=&#34;buzzer&#34;&gt;Buzzer&lt;/h1&gt;
&lt;p&gt;前面我们已经介绍了如何控制 51 单片机的 IO 口输出高低电平，这次我们通过另外一个实验来讲述 51 单片机 IO 口的输出。通过单片机的一个 IO 口控制板载无源蜂鸣器，实现蜂鸣器控制。&lt;/p&gt;
&lt;h2 id=&#34;introduction-to-buzzer&#34;&gt;Introduction to buzzer&lt;/h2&gt;
&lt;p&gt;蜂鸣器是一种一体化结构的电子讯响器，采用&lt;strong&gt;直流电压&lt;/strong&gt;供电，作发声器件。蜂鸣器主要分为压电式蜂鸣器和电磁式蜂鸣器两种类型。 压电式蜂鸣器主要由多谐振荡器、压电蜂鸣片、阻抗匹配器及共鸣箱、外壳等组成。多谐振荡器由晶体管或集成电路构成，当接通电源后（1.5~15V 直流工作电压），多谐振荡器起振,输出 1.5~5kHZ 的音频信号，阻抗匹配器推动压电蜂鸣片发声。电磁式蜂鸣器由振荡器、电磁线圈、磁铁、振动膜片及外壳等组成。接通电源后，振荡器产生的音频信号电流通过电磁线圈，使电磁线圈产生磁场，振动膜片在电磁线圈和磁铁的相互作用下，周期性地振动发声。&lt;/p&gt;
&lt;p&gt;其实一句话就可概括它们之间的区别，想要压电式蜂鸣器发声，需提供&lt;strong&gt;一定频率的脉冲信号&lt;/strong&gt;；想要电磁式蜂鸣器发声，&lt;strong&gt;只需提供电源即可&lt;/strong&gt;。 我们开发板上使用的蜂鸣器是无源蜂鸣器，属于压电式蜂鸣器类型。这里说的有源和无源，并不是指电源的意思，而是指蜂鸣器内部&lt;strong&gt;是否含有振荡电路&lt;/strong&gt;，有源蜂鸣器内部自带振荡电路，只需提供电源即可发声，而无源蜂鸣器则需提供一定频率的脉冲信号才能发声，频率大小通常在 1.5-5KHz 之间。&lt;/p&gt;
&lt;p&gt;对于无源蜂鸣器，如果改变频率就可以调节蜂鸣器音调，产生各种不同音色、音调的声音。如果改变输出电平的高低电平占空比，则可以改变蜂鸣器的声音大小。对于有源蜂鸣器，通常内部已经固定了频率，对于调节频率或占空比可能改变不了蜂鸣器的音调和音量，当然也有的有源蜂鸣器可以实现和无源蜂鸣器一样的效果。&lt;/p&gt;
&lt;h2 id=&#34;hardware-design&#34;&gt;Hardware Design&lt;/h2&gt;
&lt;p&gt;前面我们已经对 51 单片机的 GPIO 做了简单介绍，并且还使用了其中 IO 口直接控制开发板上的 LED。对于本次要实现蜂鸣器的控制，我们能否直接使用单片机的 IO 口驱动呢？&lt;/p&gt;
&lt;p&gt;答案是&lt;strong&gt;否定&lt;/strong&gt;的，因为 51 单片机 IO 口的驱动能力较弱（即使外接上拉电阻），而蜂鸣器驱动需要约 30mA，所以非常困难，即使可以驱动，那对于整个芯片的其它 IO 剩下驱动能力就更加弱甚至无法工作。所以我们不会直接使用 IO 口驱动蜂鸣器，而是通过三极管把电流放大后再驱动蜂鸣器，这样 51 单片机的 IO 口只需要提供不到 1mA 的电流就可控制蜂鸣器。**所以我们也经常说到 51 单片机是用来做控制的，而不是驱动。**我们开发板上的蜂鸣器模块电路如下图所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211024223243.png&#34; width=&#34;500px&#34; /&gt;
&lt;/div&gt;
&lt;p&gt;从图中可以看出，蜂鸣器控制管脚直接连接到 51 单片机的 &lt;code&gt;P2.5&lt;/code&gt; 管脚上。图中并没有使用三极管进行电流放大，而是使用 ULN2003 芯片来驱动，当 &lt;code&gt;P25&lt;/code&gt; 输出高电平，&lt;code&gt;BEEP&lt;/code&gt; 则输出低电平；当 &lt;code&gt;P25&lt;/code&gt; 输出低电平，&lt;code&gt;BEEP&lt;/code&gt; 则输出高电平，类似一个非门。&lt;/p&gt;
&lt;p&gt;开发板上使用的是无源蜂鸣器，它需要一定频率的脉冲（高低电平）才会发声，因此需要让 &lt;code&gt;P25&lt;/code&gt; 脚以一定频率不断输出高低电平信号才能控制蜂鸣器发出声音。&lt;/p&gt;
&lt;h2 id=&#34;software-design&#34;&gt;Software Design&lt;/h2&gt;
&lt;p&gt;我们所要实现的功能是：让蜂鸣器发出声音，一段时间后再关闭，即让 &lt;code&gt;P2.5&lt;/code&gt; 管脚输出一定频率的脉冲信号（高低电平）控制无源蜂鸣器。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;reg52.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u16;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//对系统默认数据类型进行重定义
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; u8;

sbit BEEP&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P2&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;5&lt;/span&gt;;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//将P2.5管脚定义为BEEP
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;delay_10us&lt;/span&gt;(u16 ten_us)
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(ten_us&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;);    
}


&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
{    
    u16 i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2000&lt;/span&gt;;

    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(i&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;)&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//循环2000次
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        {
            BEEP&lt;span style=&#34;color:#666&#34;&gt;=!&lt;/span&gt;BEEP;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//产生一定频率的脉冲信号
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;            delay_10us(&lt;span style=&#34;color:#666&#34;&gt;100&lt;/span&gt;); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//改变此处会使得声音的频率变化，越大越低沉
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        }
        i&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//清零
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        BEEP&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//关闭蜂鸣器
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    }        
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;静态数码管&#34;&gt;静态数码管&lt;/h1&gt;
&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;数码管是一种半导体发光器件，其基本单元是发光二极管。数码管也称 LED 数码管。数码管按段数可分为七段数码管和八段数码管，八段数码管比七段数码管多一个发光二极管单元，也就是多一个小数点（DP），这个小数点可以更精确的表示数码管想要显示的内容；按能显示多少个（8）可分为 1 位、 2 位、 3 位、 4 位、 5 位、 6 位、7 位等数码管。按发光二极管单元连接方式可分为共&lt;strong&gt;阳&lt;/strong&gt;极数码管和共&lt;strong&gt;阴&lt;/strong&gt;极数码管。&lt;/p&gt;
&lt;p&gt;共阳数码管是指将所有发光二极管的阳极接到一起形成公共阳极（COM）的数码管，共阳数码管在应用时应将公共极 COM 接到 +5V，当某一字段发光二极管的阴极为低电平时，相应字段就点亮，当某一字段的阴极为高电平时，相应字段就不亮。&lt;/p&gt;
&lt;p&gt;共阴数码管是指将所有发光二极管的阴极接到一起形成公共阴极（COM）的数码管，共阴数码管在应用时应将公共极 COM 接到地线 GND 上，当某一字段发光二极管的阳极为高电平时，相应字段就点亮，当某一字段的阳极为低电平时，相应字段就不亮。&lt;/p&gt;
&lt;h2 id=&#34;数码管表&#34;&gt;数码管表&lt;/h2&gt;
&lt;p&gt;不管将几位数码管连在一起，数码管的显示原理都是一样的，都是靠点亮内部的发光二极管来发光。从上述共阳和共阴码表中不难发现，它们的数据正好是相互取反的值。比如共阴数码管数字 0 段码：0x3f，其二进制是：0011 1111，取反后为：1100 0000， 转换成 16 进制即为 0XC0，其他段码依此类推。该段码数据由来，是将 a 段作为 最低位，b 段作为次低位，其他按顺序类推，dp 段为最高位，共 8 位，正好和 51 单片机的一组端口数一样，因此可以直接使用某一组端口控制数码管的段选数据口，比如 P0 口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共阴数码管码表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;0x3f&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x06&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x5b&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x4f&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x66&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x6d&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x7d&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x07&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x00&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x7f&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x6f&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x77&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x7c&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x39&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x5e&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x79&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x71&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;C&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;D&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;E&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;F&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;共阳数码管码表&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;0xC0&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0xF9&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0xA4&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0xB0&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x99&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x92&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0x82&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0xF8&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;0xFF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x80&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x90&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x88&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x83&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0xC6&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0xA1&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x86&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;0x8E&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;C&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;D&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;E&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;F&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;显示原理&#34;&gt;显示原理&lt;/h2&gt;
&lt;p&gt;LED 数码管显示器工作方式有两种：静态显示方式和动态显示方式。静态显示的特点是每个数码管的段选必须接一个 8 位数据线来保持显示的字形码。当送入一次字形码后，显示字形可一直保持，直到送入新字形码为止。这种方法的&lt;strong&gt;优点是占用 CPU 时间少，显示便于监测和控制&lt;/strong&gt;。&lt;strong&gt;缺点是硬件电路比较复杂，成本较高&lt;/strong&gt;，比如使用 4 个静态数码管，那么就得 32 个 IO 来控制，这对 51 单片机来说是无法承受的，正因为如此才会有后面章节动态数码实验的讲解。&lt;/p&gt;
&lt;p&gt;动态显示的特点是将所有数码管的段选线并联在一起，由位选线控制是哪一位数码管有效。选亮数码管采用动态扫描显示。所谓动态扫描显示即轮流向各位数码管送出字形码和相应的位选，利用发光管的余辉和人眼视觉暂留作用，使人的感觉好像各位数码管同时都在显示。&lt;strong&gt;动态显示的亮度比静态显示要差一些，所以在选择限流电阻时应略小于静态显示电路中的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本次实验使用的数码管虽然是动态数码管电路，但我们依然可以使用数码管其中一位来学习静态数码管知识。本次实验主要介绍静态数码管的控制，有关动态数码管控制将在以后介绍。&lt;/p&gt;
&lt;h2 id=&#34;hardware-design-1&#34;&gt;Hardware Design&lt;/h2&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211024231932.png&#34; width=&#34;700px&#34; /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;software-design-1&#34;&gt;Software Design&lt;/h2&gt;
&lt;p&gt;我们所要实现的功能是：控制静态数码管显示数字 0，即让 &lt;code&gt;P0&lt;/code&gt; 端口输出数字 0 的段码 &lt;code&gt;0x3f&lt;/code&gt;（共阴）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;reg52.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u16;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//对系统默认数据类型进行重定义
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; u8;

&lt;span style=&#34;color:#080&#34;&gt;#define SMG_A_DP_PORT P0    &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//使用宏定义数码管段码口
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//共阴极数码管显示0~F的段码数据
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;u8 gsmg_code[&lt;span style=&#34;color:#666&#34;&gt;17&lt;/span&gt;]&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#666&#34;&gt;0x3f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x06&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x5b&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x4f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x66&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x6d&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x7d&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x07&lt;/span&gt;,
                &lt;span style=&#34;color:#666&#34;&gt;0x7f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x6f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x77&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x7c&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x39&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x5e&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x79&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x71&lt;/span&gt;};

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
{    
    SMG_A_DP_PORT&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;gsmg_code[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;];&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//将数组第1个数据赋值给数码管段选口
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
    {
           
    }        
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;动态数码管&#34;&gt;动态数码管&lt;/h1&gt;
&lt;p&gt;前面我们已经介绍了如何使用 51 单片机控制静态数码管显示，在实际应用中通常都需要显示多位数值，如果采用静态数码管显示就不够好，因此就需要采用另外一种显示方式，即数码管动态显示。开发板上板载 2 个四位一体的共阴数码管，我们就来介绍下如何使用 51 单片机控制动态数码管显示。所要实现的功能是：控制动态数码管从左至右显示数字 0-7。&lt;/p&gt;
&lt;h2 id=&#34;introduction-1&#34;&gt;Introduction&lt;/h2&gt;
&lt;p&gt;多位数码管，即两个或两个以上单个数码管并列集中在一起形成一体的数码管。当多位一体时，它们内部的公共端是独立的，而负责显示什么数字的段线（a-dp）全部是连接在一起的，独立的公共端可以控制多位一体中的哪一位数码管点亮，而连接在一起的段线可以控制这个能点亮数码管亮什么数字，通常我们把公共端叫做“位选线”，连接在一起的段线叫做“段选线”，有了这两个线后，通过单片机及外部驱动电路就可以控制任意的数码管显示任意的数字了。&lt;/p&gt;
&lt;p&gt;一般一位数码管有 10 个引脚，二位数码管也是 10 个引脚，四位数码管是 12 个引脚，关于具体的引脚及段、位标号大家可以查询相关资料，最简单的办法就是用数字万用表测量，若没有数字万用表也可用 5V 直流电源串接 1k 电阻后测量，将测量结果记录，通过统计便可绘制出引脚标号。多位数码管有许多是按 一定要求设计的，引脚不完全按照一般规则设定，所以需要在使用时查找手册，最直接的办法就是按照数码管上的标示向生产商要求。我们开发板上使用了 2 个四位一体的共阴数码管，这样可在上面同时显示 8 个数值。&lt;/p&gt;
&lt;h3 id=&#34;显示原理-1&#34;&gt;显示原理&lt;/h3&gt;
&lt;p&gt;多位数码管依然可以静态显示，但是显示时要么只显示一位数码管，要么多位同时显示相同内容。当多位数码管应用于某一系统时，它们的“位选”是可独立控制的，而“段选”是连接在一起的，我们可以通过位选信号控制哪几个数码管亮，而在同一时刻，位选选通的所有数码管上显示的数字始终都是一样的，因为它们的段选是连接在一起的，送入所有数码管的段选信号都是相同的，所以它们显示的数字必定一样，数码管的这种显示方法叫做静态显示。&lt;/p&gt;
&lt;p&gt;而动态显示，就是利用减少段选线，分开位选线，&lt;strong&gt;利用位选线不同时选择通断，改变段选数据来实现的&lt;/strong&gt;。比如在第一次选中第一位数码管时，给段选数据 0，下一次位选中第二位数码管时显示 1。为了在显示 1 的时候，0 不会消失（当然实际上是消失了），必须在人肉眼观察不到的时间里再次点亮第一次点亮的 0。 而这时就需要记住，人的肉眼正常情况下只能分辨变化超过 24ms 间隔的运动。也就是说，在下一次点亮 0 这个数字的时间差不得大于 24ms。这时就会发现，数码管点亮是在向右或者向左一位一位点亮，形成了动态效果。如果把间隔时间改长就能直接展现这一现象。&lt;/p&gt;
&lt;p&gt;74HC138 总结：A0、A1、A2 输入就相当于 3 位 2 进制数，A0 是低位，A1 是次高位，A2 是高位。而 Y0-Y7 具体哪一个输出有效电平，就看输入二进制对应的十进制数值。比如输入是 101（A2，A1，A0），其对应的十进制数是 5，所以 Y5 输出有效电平（低电平）。&lt;/p&gt;
&lt;h2 id=&#34;software-design-2&#34;&gt;Software Design&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;reg52.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u16;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//对系统默认数据类型进行重定义
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; u8;

&lt;span style=&#34;color:#080&#34;&gt;#define SMG_A_DP_PORT    P0    &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//使用宏定义数码管段码口
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//定义数码管位选信号控制脚
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;sbit LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P2&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;
sbit LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P2&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;;
sbit LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;P2&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;;

&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//共阴极数码管显示0~F的段码数据
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;u8 gsmg_code[&lt;span style=&#34;color:#666&#34;&gt;17&lt;/span&gt;]&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#666&#34;&gt;0x3f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x06&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x5b&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x4f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x66&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x6d&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x7d&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x07&lt;/span&gt;,
                &lt;span style=&#34;color:#666&#34;&gt;0x7f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x6f&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x77&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x7c&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x39&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x5e&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x79&lt;/span&gt;,&lt;span style=&#34;color:#666&#34;&gt;0x71&lt;/span&gt;};

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;delay_10us&lt;/span&gt;(u16 ten_us)
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(ten_us&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;);    
}


&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;smg_display&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt;)
{
    u8 i&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;

    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(i&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;;i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;switch&lt;/span&gt;(i)&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//位选
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        {
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;5&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;6&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;:&lt;/span&gt; LSC&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSB&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;LSA&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;break&lt;/span&gt;;
        }
        SMG_A_DP_PORT&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;gsmg_code[i];&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//传送段选数据
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        delay_10us(&lt;span style=&#34;color:#666&#34;&gt;100&lt;/span&gt;);&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//延时一段时间，等待显示稳定
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        SMG_A_DP_PORT&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0x00&lt;/span&gt;;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//消音
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    }
}


&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
{    
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
    {
        smg_display();
    }        
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该程序是根据动态数码管显示原理所编写，即选中所要显示的那位数码管，然后发送在该位数码管上所要显示的段码数据，延时一定时间后在将段选口清零即消隐（消除之前的显示），如此循环 8 次即可实现 8 位数码管显示。&lt;strong&gt;在动态显示中，要注意延时时间，只要保证在人肉眼所能感觉时间之内即可，让我们看到所要显示的内容就像是同时显示一样。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;普中51单片机开发攻略&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
    <item>
      <title>MCS 51 Basics (1)</title>
      <link>https://preminstrel.github.io/blog/post/2021/10/18/mcs-51-basics-1/</link>
      <pubDate>Mon, 18 Oct 2021 22:45:32 +0800</pubDate>
      <author>preminstrel@gmail.com (Hanshi Sun)</author>
      <guid>https://preminstrel.github.io/blog/post/2021/10/18/mcs-51-basics-1/</guid>
      
      <description>&lt;p&gt;最近因为在上微机原理课，所以买了51单片机（MCS 51）来进行实验学习。&lt;/p&gt;
&lt;h1 id=&#34;introduction-to-mcu&#34;&gt;Introduction to MCU&lt;/h1&gt;
&lt;p&gt;一台能够工作的计算机要有这样几个部件构成：CPU（进行运算、控制）、RAM （&lt;strong&gt;数据&lt;/strong&gt;存储）、ROM（&lt;strong&gt;程序&lt;/strong&gt;存储）、输入/输出设备（例如：串行口、并行输出口等）。&lt;/p&gt;
&lt;p&gt;在个人计算机上这些部件被分成若干块芯片，安装一个称之为&lt;strong&gt;主板&lt;/strong&gt;的印刷线路板上。而在单片机中，这些部件全部被做到一块集成电路芯片中，所以就称为&lt;strong&gt;单片机（也称微控制器 MCU）&lt;/strong&gt;，而且有一些单片机中除了上述部份外，还集成了其它部份如 A/D，D/A 等。体积不大，一般用 40 脚封装， 当然功能多一些单片机也有引脚比较多的，如 68 引脚， 功能少的只有 10 多个或 20 多个引脚，有的甚至只 8 只引脚。&lt;/p&gt;
&lt;h2 id=&#34;mcs-51&#34;&gt;MCS 51&lt;/h2&gt;
&lt;p&gt;51 单片机是对所有兼容 Intel 8031 指令系统的单片机的统称。51 单片机是基础入门的 一个单片机，还是应用最广泛的一种。需要注意的是 &lt;strong&gt;51 系列的单片机一般不具备自编程能力&lt;/strong&gt;。 80C51 是 MCS-51 系列中的一个典型品种；其它厂商以 8051 为基核开发出的CMOS 工艺单片机产品统称为 80C51 系列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总线（BUS）&lt;strong&gt;是单片机各部件之间传送信息的公共通道。单片机中有&lt;/strong&gt;内部总线&lt;/strong&gt;和&lt;strong&gt;外部总线&lt;/strong&gt;两类，内部总线是 CPU 内部之间的连线，外部总线是指 CPU 与其它部件之间的连线；外部总线有三种: &lt;strong&gt;数据总线 DB（Data Bus）,地址总线 AB（Address Bus）和控制总线 CB（Control Bus）&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;stc89cxx-chip&#34;&gt;STC89Cxx Chip&lt;/h2&gt;
&lt;p&gt;我国芯片技术的快速发展，宏晶公司推出了增强型51单片机 STC89Cxx/STC90Cxx 等系列，除内部资源及功能大大增强外，还有一个非常重要的是它支持 &lt;strong&gt;ISP（在系统可编程）/IAP（在应用可编程）&lt;/strong&gt;，无需专用编程器或专用仿真器。开发板上使用的 STC89C52 或者 STC89C516，这两款芯片以及其他 STC89Cxx 或者 STC90Cxx 除 Flash 和 RAM 容量差异外，内部资源功能几乎一样。下面我们看下常见 PDIP 封装（直插封装）的 51 单片机芯片实物图如下所示：&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211018225338.png&#34; width=&#34;500px&#34; /&gt;
&lt;/div&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;S/N&lt;/th&gt;
&lt;th&gt;板载资源&lt;/th&gt;
&lt;th&gt;Details&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;数码管模块&lt;/td&gt;
&lt;td&gt;2个四位一体共阴数码管，可以显示8位数字字符，如时钟和密码等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;LCD1602 接口&lt;/td&gt;
&lt;td&gt;兼容 LCD1602/LCD9648 液晶屏，可以显示数字字符等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;LCD12864 接口&lt;/td&gt;
&lt;td&gt;兼容 LCD9648/MiniLCD12864/带字库 LCD12864液晶，可以显示汉字和图像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8*8 LED 点阵&lt;/td&gt;
&lt;td&gt;可以显示数字、字符和图形&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;LED 模块&lt;/td&gt;
&lt;td&gt;8个 LED，可以实现流水灯等显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;矩阵按键&lt;/td&gt;
&lt;td&gt;4*4 矩阵按键，可以用作计算器、密码锁等应用的输入装置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;红外接收头&lt;/td&gt;
&lt;td&gt;NEC 协议，可以实现遥控&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;DS18B20 温度传感器&lt;/td&gt;
&lt;td&gt;可以实现温度采集控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;NRF24L01 接口&lt;/td&gt;
&lt;td&gt;可以实现2.4G远程遥控通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;独立按键&lt;/td&gt;
&lt;td&gt;4个按键，可以用作按键输入控制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;MicroUSB 接口&lt;/td&gt;
&lt;td&gt;可以用作电源输入、程序下载等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;USB 转 TTL 模块&lt;/td&gt;
&lt;td&gt;CH340C 芯片，可用作电脑 USB 与单片机串口下载和通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;3.3V 电源模块&lt;/td&gt;
&lt;td&gt;ASM1117-3.3 芯片，将5V转为3.3V供用户使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;电源开关&lt;/td&gt;
&lt;td&gt;系统电源控制开关&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;ADC/DAC 模块&lt;/td&gt;
&lt;td&gt;XPT2046 芯片用作 ADC，LM358+PWM 作为 DAC，可采集外部模拟信号和输出模拟电压&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;EEPROM 模块&lt;/td&gt;
&lt;td&gt;AT24C02 芯片，可以存储256字节数据，掉电不丢失&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;17&lt;/td&gt;
&lt;td&gt;复位按键&lt;/td&gt;
&lt;td&gt;系统复位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;18&lt;/td&gt;
&lt;td&gt;无源蜂鸣器&lt;/td&gt;
&lt;td&gt;可以用作报警提示、音乐等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;DS1302 时钟模块&lt;/td&gt;
&lt;td&gt;DS1302 芯片，可以用作时钟发生&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;步进电机驱动模块&lt;/td&gt;
&lt;td&gt;ULN2003 芯片，可以用作直流电机、28BYJ48 步进电机驱动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;STC89Cxx 单片机座及 IO&lt;/td&gt;
&lt;td&gt;固定单片机，并将所有 IO 引出，方便用户二次开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;TFTLCD 模块接口&lt;/td&gt;
&lt;td&gt;与3号接口组合可连接 TFTLCD，方便用户二次开发&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;23&lt;/td&gt;
&lt;td&gt;74HC595&lt;/td&gt;
&lt;td&gt;拓展 IO，控制 LED 点阵&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;74HC245&lt;/td&gt;
&lt;td&gt;驱动数码管段选显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;74HC138&lt;/td&gt;
&lt;td&gt;驱动数码管位选显示&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;单片机最小系统构成&#34;&gt;单片机最小系统构成&lt;/h1&gt;
&lt;p&gt;若要使系统正常运行，必须确保单片机的最小系统稳定工作。51 单片机的最小系统由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;晶振电路&lt;/li&gt;
&lt;li&gt;复位电路&lt;/li&gt;
&lt;li&gt;电源电路&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;晶振电路提供时钟给单片机工作，犹如人的心脏。&lt;/p&gt;
&lt;p&gt;复位电路提供系统复位操作，当系统出现运行不正常或者死机等情况时，可以通过复位按键重新启动系统。&lt;/p&gt;
&lt;p&gt;电源电路也是非常关键的一个部分，因为单片机对供电电压是有要求的，如果电压过大将烧坏芯片，如果电压过小系统将运行不了。所以选择一个合适稳定的电源电路是非常关键的。 还有一点非常重要，由于 51 单片机的 P0 口是漏极开路，即&lt;strong&gt;输出高电平会导致高阻态，要让它输出高电平就必须外接上拉电阻&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;晶振电路&#34;&gt;晶振电路&lt;/h2&gt;
&lt;p&gt;由于单片机正常工作需要一个&lt;strong&gt;时钟&lt;/strong&gt;，因此就需要在其晶振引脚上外接晶振 （我们使用的 STC89CXX 单片机晶振引脚是 18 和 19 脚），至于需要多大晶振这就取决于你所使用的单片机，由于使用的是 51 单片机，其时钟频率可在 0-40MHZ 上运行，一般情况下建议选择 12M（适合计算延时时间）或者是 11.0592M（适合串口通信）。&lt;/p&gt;
&lt;p&gt;若直接将此晶振接入单片机晶振引脚，会发现系统工作不稳定，这是因为晶振起振的一瞬间会产生一些电感，为了消除这个电感所带来的干扰，可以在此晶振两端分别加上一个电容，电容的选取需要无极性的， 另一端需要共地。根据选取的晶振大小决定电容值，通常电容可在 10-33PF 值范围内选取。我们使用的是 33PF 电容。这样一来就构成了晶振电路。只有保证晶振电路稳定，单片机才能继续工作。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211022115957.png&#34; width=&#34;400px&#34; /&gt;
&lt;/div&gt;
&lt;h2 id=&#34;复位电路&#34;&gt;复位电路&lt;/h2&gt;
&lt;p&gt;前面已经将晶振电路搭建完成，晶振需要无时无刻给单片机提供运行周期。但即使时钟周期在不停的运行，系统也有可能会出现崩溃或者瘫痪状态。&lt;/p&gt;
&lt;p&gt;为了处理这一情况，需要设计一个复位电路来实现此功能。单片机引脚当中有一个 &lt;code&gt;RST&lt;/code&gt; 复位引脚，STC89CXX 单片机是&lt;strong&gt;高电平复位&lt;/strong&gt;，所以只需要让这个引脚保持一段时间高电平就可以。要实现此功能通常有两种方式，一种是通过按键进行手动复位，还有一种是上电复位，即电源开启后自动复位。&lt;/p&gt;
&lt;p&gt;手动复位是通过一个按键及电容电阻所组成，利用按键的开关功能实现复位，按键按下后 &lt;code&gt;VCC&lt;/code&gt; 直接进入到单片机 &lt;code&gt;RST&lt;/code&gt; 引脚，松开后 &lt;code&gt;VCC&lt;/code&gt; 断开，&lt;code&gt;RST&lt;/code&gt; 被电阻拉为低电平。这一合一开就实现了手动复位。当按下按键 &lt;code&gt;RSTK1&lt;/code&gt;，&lt;code&gt;VCC&lt;/code&gt; 直接连接到 &lt;code&gt;RST&lt;/code&gt; 复位脚，&lt;code&gt;VCC&lt;/code&gt; 是高电平所以系统复位。&lt;/p&gt;
&lt;p&gt;而自动复位主要是利用 RC 充放电功能，电源已开启，由于电容隔直，&lt;code&gt;VCC&lt;/code&gt; 直接进入 &lt;code&gt;RST&lt;/code&gt;，然后电容开始慢慢充电，直到充电完成，此时 &lt;code&gt;RST&lt;/code&gt; 被电阻拉低。 这样就起到上电复位的效果。&lt;/p&gt;
&lt;h2 id=&#34;电源电路&#34;&gt;电源电路&lt;/h2&gt;
&lt;p&gt;任何电子器件都需要有一个合适的电源进行供电，没有电源，系统是不会工作的。STC89CXX 单片机的工作电压是 3.3-5.5V 范围， 通常我们使用 5V 直流。将电源接入到各芯片电源引脚即可。&lt;/p&gt;
&lt;p&gt;开发板上还预留了 &lt;code&gt;P3&lt;/code&gt;（5V/3V）端子，这些端子可以很方便的给外部模块连接电源。&lt;/p&gt;
&lt;h1 id=&#34;keil-c51-template&#34;&gt;Keil C51 template&lt;/h1&gt;
&lt;p&gt;我们使用 Keil 来创建完美地工程模板，为后面的程序编写带来方便。&lt;/p&gt;
&lt;p&gt;CPU 型号选择 &lt;code&gt;AT89C52&lt;/code&gt;，在 &lt;code&gt;Configuration&lt;/code&gt; 中配置好合适的字体后，我们创建一个 &lt;code&gt;main.c&lt;/code&gt; 文件，写入以下代码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/* main.c */&lt;/span&gt;

&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;reg52.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
    {
        
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;头文件作用&#34;&gt;头文件作用&lt;/h2&gt;
&lt;p&gt;在代码中引用头文件，其实际意义就是将这个头文件中的全部内容放到引用头文件的位置处，免去我们每次编写同类程序都要将头文件中的语句重复编写。&lt;/p&gt;
&lt;p&gt;在代码中加入头文件有两种书写方法，分别为&lt;code&gt;#include &amp;lt;reg52.h&amp;gt;&lt;/code&gt;和&lt;code&gt;#include&amp;quot;reg52.h&amp;quot;&lt;/code&gt;，这两种写法是有区别的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;包含头文件时，编译器先进入到&lt;strong&gt;软件安装文件夹&lt;/strong&gt;处开始搜索这个头文件，也就是 &lt;code&gt;KEILC51/C51/INC&lt;/code&gt; 这个文件夹下，如果这个文件夹没有引用的头文件，编译器将会报错。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt;包含头文件时，编译器先进入到&lt;strong&gt;当前工程所在文件夹&lt;/strong&gt;处开始搜索该头文件，如果当前工程所在文件夹下没有该头文件，编译器&lt;strong&gt;将继续回到软件安装文件夹处搜索这个头文件&lt;/strong&gt;，若找不到该头文件，编译器将报错。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;点亮第一个-led&#34;&gt;点亮第一个 LED&lt;/h1&gt;
&lt;p&gt;不论学习什么单片机，最简单的外设莫过于 IO 口的高低电平控制，这里我们使用创建好的工程模板上，通过控制 51 单片机的 GPIO 使开发板上的 LED 灯点亮。&lt;/p&gt;
&lt;h2 id=&#34;introduction-to-gpio&#34;&gt;Introduction to GPIO&lt;/h2&gt;
&lt;h3 id=&#34;concepts&#34;&gt;Concepts&lt;/h3&gt;
&lt;p&gt;GPIO（&lt;em&gt;general purpose intput output&lt;/em&gt;）是通用输入输出端口的简称，可以&lt;strong&gt;通过软件来控制其输入和输出&lt;/strong&gt;。51 单片机芯片的 GPIO 引脚与外部设备连接 起来，从而实现与外部通讯、控制以及数据采集的功能。GPIO 最简单的应用还属点亮 LED 灯了，只需通过软件控制 GPIO 输出高低电平即可。&lt;/p&gt;
&lt;p&gt;GPIO 还可以作为输入控制，比如在引脚上接入一个按键，通过电平的高低判断按键是否按下。 我们开发板上使用的 51 单片机型号是 STC89C52 或 STC89C516，此芯片共有 40 引脚。注意，并不是所有的引脚都是 GPIO，51 单片机引脚可以分为以下三个大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;电源引脚：引脚图中的 &lt;code&gt;VCC&lt;/code&gt;、 &lt;code&gt;GND&lt;/code&gt; 都属于电源引脚。&lt;/li&gt;
&lt;li&gt;晶振引脚：引脚图中的 &lt;code&gt;XTAL1&lt;/code&gt;、&lt;code&gt;XTAL2&lt;/code&gt; 都属于晶振引脚。&lt;/li&gt;
&lt;li&gt;复位引脚：引脚图中的 &lt;code&gt;RST/VPD&lt;/code&gt; 属于复位引脚，不做其他功能使用。&lt;/li&gt;
&lt;li&gt;下载引脚：51 单片机的串口功能引脚（&lt;code&gt;TXD&lt;/code&gt;、&lt;code&gt;RXD&lt;/code&gt;）可以作为下载引脚使用。&lt;/li&gt;
&lt;li&gt;GPIO 引脚：引脚图中带有 &lt;code&gt;Px.x&lt;/code&gt; 等字样的均属于 GPIO 引脚。从引脚图可以看出，GPIO 占用了芯片大部分的引脚，共达 32 个，分为了 4 组，&lt;code&gt;P0&lt;/code&gt;、&lt;code&gt;P1&lt;/code&gt;、 &lt;code&gt;P2&lt;/code&gt;、&lt;code&gt;P3&lt;/code&gt;，每组为 8 个 IO，而且在 &lt;code&gt;P3&lt;/code&gt; 组中每个 IO 都具备额外功能，只要通过相应的寄存器设置即可配置对应的附加功能，同一时刻，每个引脚只能使用该引脚。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;framework&#34;&gt;Framework&lt;/h3&gt;
&lt;h4 id=&#34;p0-端口&#34;&gt;&lt;code&gt;P0&lt;/code&gt; 端口&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;P0&lt;/code&gt; 端口含有 8 位引脚，下图为其中一个，其它几个与之完全一致，因此只需了解当中一个即可。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;P0&lt;/code&gt; 端口由锁存器、输入缓冲器、切换开关、一个非门、一个与非门及场效应管驱动电路构成。再看图的最右边，标号为 &lt;code&gt;P0.x&lt;/code&gt; 引脚的图标，也就是说 &lt;code&gt;P0.x&lt;/code&gt; 引脚可以是 &lt;code&gt;P0.0&lt;/code&gt; 到 &lt;code&gt;P0.7&lt;/code&gt; 的任何一位，即在 &lt;code&gt;P0&lt;/code&gt; 口有 8 个与上图相同的电路组成。&lt;/p&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/20211022225548.png&#34; width=&#34;400px&#34; /&gt;
&lt;/div&gt;
&lt;h5 id=&#34;输入缓冲器&#34;&gt;输入缓冲器&lt;/h5&gt;
&lt;p&gt;在 &lt;code&gt;P0&lt;/code&gt; 口中，有两个三态的缓冲器，在学数字电路时，我们已知道，三态门有三个状态，即在输出端可以是高电平、低电平，同时还有一种就是高阻状态（或称为禁止状态）。&lt;/p&gt;
&lt;p&gt;上图一个是读锁存器的缓冲器，也就是说，要读取 D 锁存器输出端 Q 的数据，那就得使读锁存器的这个缓冲器的三态控制端（上图中标号为‘读锁存器’端）有效。下面一个是读引脚的缓冲器，要读取 &lt;code&gt;P0.x&lt;/code&gt; 引脚上的数据，也要使标号为‘读引脚’的这个三态缓冲器的控制端有效，引脚上的数据才会传输到我们单片机的内部数据总线上。&lt;/p&gt;
&lt;h5 id=&#34;d-锁存器&#34;&gt;D 锁存器&lt;/h5&gt;
&lt;p&gt;构成一个锁存器，通常要用一个时序电路，时序的单元电路在学数字电路时我们知道，一个触发器可以保存一位的二进制数（即具有保持功能），在 51 单片机的 32 根 I/O 口线中都是用一个 D 触发器来构成锁存器的。上图中的 D 锁存器，D 端是数据输入端，CP（CLK）是控制端（也就是时序控制信号输 入端），Q 是输出端，Q 非是反向输出端。&lt;/p&gt;
&lt;p&gt;对于 D 触发器来讲，当 D 输入端有一个输入信号，如果这时控制端 CP 没有信号（也就是时序脉冲没有到来），这时输入端 D 的数据是无法传输到输出端 Q 及反向输出端 Q 非的。如果时序控制端 CP 的时序脉冲一旦到了，这时 D 端输入的数据就会传输到 Q 及 Q 非端。数据传送过来后，当 CP 时序控制端的时序信号消失了，这时，输出端还会保持着上次输入端 D 的数据（即把上次的数据锁存起来了）。如果下一个时序控制脉冲信号来了，这时 D 端的数据才再次传送到 Q 端，从而改变 Q 端的状态。&lt;/p&gt;
&lt;h5 id=&#34;多路开关&#34;&gt;多路开关&lt;/h5&gt;
&lt;p&gt;在 51 单片机中，当内部的存储器够用（也就是不需要外扩展存储器时，这里讲的存储器包括数据存储器及程序存储器）时，&lt;code&gt;P0&lt;/code&gt; 口可以作为通用的输入输出端口（即 I/O）使用，对于 8031（内部没有 ROM）的单片机或者编写的程序超 过了单片机内部的存储器容量，需要外扩存储器时，&lt;code&gt;P0&lt;/code&gt; 口就作为‘地址/数据’ 总线使用。那么这个多路选择开关就是用于选择是做为普通 I/O 口使用还是作为 ‘数据/地址’总线使用的选择开关了。上图当多路开关与下面接通时， &lt;code&gt;P0&lt;/code&gt; 口是作为普通的 I/O 口使用的，当多路开关是与上面接通时，&lt;code&gt;P0&lt;/code&gt; 口是作为‘地址/数据’总线使用的。&lt;/p&gt;
&lt;h4 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;P0&lt;/code&gt; 口是漏极开路，要使其输出高电平，必须外接上拉电阻，通常选择 4.7K~10K 阻值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P0&lt;/code&gt;、&lt;code&gt;P1&lt;/code&gt;、&lt;code&gt;P2&lt;/code&gt; 几乎都用作普通 I/O 口使用，既可作为输入，又可作为输出。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P3&lt;/code&gt; 口既可用作普通 I/O 口，又可作为第二功能使用，比如串口、外部中断、计数器等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;introduction-to-led&#34;&gt;Introduction to LED&lt;/h2&gt;
&lt;p&gt;LED 即发光二极管。它具有单向导电性，&lt;strong&gt;通过 5mA 左右电流即可发光，电流越大，其亮度越强，但若电流过大，会烧毁二极管，一般我们控制在 3 mA-20mA 之间&lt;/strong&gt;，通常我们会在 LED 管脚上串联一个电阻，目的就是为了限制通过发光二极管的电流不要太大，因此这些电阻又可以称为“限流电阻”。当发光二极管发光时，测量它两端电压约为 1.7V，这个电压又叫做发光二极管的“导通压降”。&lt;/p&gt;
&lt;h2 id=&#34;hardware-design&#34;&gt;Hardware Design&lt;/h2&gt;
&lt;div align=center&gt;
&lt;img src=&#34;https://preminstrel.github.io/blog/img/image-20211023131351130.png&#34; width=&#34;300px&#34; /&gt;
&lt;/div&gt;
在前面介绍过如何查看原理图，相同网络标号表示它们是连接在一起 的，因此 `D1`-`D8` 连接到单片机的 `P20`-`P27` 口。图中 LED 采用共阳接法，即所有 LED 阳极管脚接电源 `VCC`，阴极管脚通过一个 470 欧的限流电阻接到 `P2` 口上。
&lt;p&gt;根据前面 LED 的介绍我们知道，要让 LED 发光即对应的阴极管脚应该为低电平，若为高电平则熄灭。 如果要想 51 单片机控制 LED，就必须通过单片机管脚在 &lt;code&gt;P2&lt;/code&gt; 口上输出低电平。&lt;/p&gt;
&lt;h2 id=&#34;software-design&#34;&gt;Software Design&lt;/h2&gt;
&lt;h3 id=&#34;点亮第一个-led-1&#34;&gt;点亮第一个 LED&lt;/h3&gt;
&lt;p&gt;这里所要实现的功能是：点亮 &lt;code&gt;D1&lt;/code&gt; 指示灯，即让 &lt;code&gt;P2.0&lt;/code&gt; 管脚输出一个低电平。 完成后可再控制 &lt;code&gt;D1&lt;/code&gt; 指示灯闪烁，即间隔一段时间点亮和熄灭 &lt;code&gt;D1&lt;/code&gt; 指示灯。具体过程是使用 &lt;code&gt;sbit&lt;/code&gt; 关键字来定义 &lt;code&gt;P2.0&lt;/code&gt; 管脚，定义好后即可使用 &lt;code&gt;LED1&lt;/code&gt; 来替代 &lt;code&gt;P2.0&lt;/code&gt; 口的操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;reg52.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u16;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//对系统默认数据类型进行重定义
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; u8;

sbit LED1 &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; P2&lt;span style=&#34;color:#666&#34;&gt;^&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//用sbit将P2.0管脚定义为LED1
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;/*******************************************************************************
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 函 数 名       : delay_10us
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 函数功能         : 延时函数，ten_us=1时，大约延时10us
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 输    入       : ten_us
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;* 输    出         : 无
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;*******************************************************************************/&lt;/span&gt;
&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;delay_10us&lt;/span&gt;(u16 ten_us)
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(ten_us&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;);    
}

&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
    {
        LED1&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//点亮
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        delay_10us(&lt;span style=&#34;color:#666&#34;&gt;50000&lt;/span&gt;); &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//大约延时450ms
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        LED1&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//熄灭
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        delay_10us(&lt;span style=&#34;color:#666&#34;&gt;50000&lt;/span&gt;); 
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;led-流水灯实验&#34;&gt;LED 流水灯实验&lt;/h3&gt;
&lt;p&gt;如果要实现 LED 流水灯，只需循环让 &lt;code&gt;D1&lt;/code&gt;-&lt;code&gt;D8&lt;/code&gt; 指示灯逐个点亮。同样本实验也需要延时。要实现循环点亮，点亮 &lt;code&gt;D1&lt;/code&gt; 且把 &lt;code&gt;D2&lt;/code&gt;-&lt;code&gt;D8&lt;/code&gt; 熄灭，延时一段时间后再点亮 &lt;code&gt;D2&lt;/code&gt; 且把 &lt;code&gt;D1&lt;/code&gt;、 &lt;code&gt;D3&lt;/code&gt;-&lt;code&gt;D8&lt;/code&gt; 熄灭，延时一段时间后再点亮 &lt;code&gt;D3&lt;/code&gt; 且把 &lt;code&gt;D1&lt;/code&gt;-&lt;code&gt;D2&lt;/code&gt;、&lt;code&gt;D4&lt;/code&gt;-&lt;code&gt;D8&lt;/code&gt; 熄灭，如此循环，这样就可以很简单的实现 LED 流水灯实验，当然不推荐此种方法。&lt;/p&gt;
&lt;p&gt;在前面我们学习了 C 语言相关的基础知识，里面有移位以及循环语句操作，根据流水灯实现原理，即 IO 口由低往高或者由高往低逐个输出低电平特点，那么我们可以将移位操作以及循环结合进来。实现代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;reg52.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#080&#34;&gt;&amp;#34;intrins.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#080&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u16;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//对系统默认数据类型进行重定义
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;char&lt;/span&gt; u8;

&lt;span style=&#34;color:#080&#34;&gt;#define LED_PORT    P2    &lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//使用宏定义P2端口
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;delay_10us&lt;/span&gt;(u16 ten_us)
{
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(ten_us&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;);    
}


&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;main&lt;/span&gt;()
{    
    u8 i&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;
    LED_PORT&lt;span style=&#34;color:#666&#34;&gt;=~&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0x01&lt;/span&gt;;
    delay_10us(&lt;span style=&#34;color:#666&#34;&gt;50000&lt;/span&gt;);
    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)
    {
        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//使用移位 + 循环实现流水灯
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt; (i&lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;8&lt;/span&gt;; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)
        {
            LED_PORT&lt;span style=&#34;color:#666&#34;&gt;=~&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;0x01&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;i);  &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;//将 1 右移 i 位，然后取反将结果赋值到 LED_PORT;
&lt;/span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;            delay_10us(&lt;span style=&#34;color:#666&#34;&gt;50000&lt;/span&gt;);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;0X01&amp;lt;&amp;lt;i&lt;/code&gt; 表示 i 增加 1 次，&lt;code&gt;0x01&lt;/code&gt; 中的 1 就移动多少位，因为 1（高电平）不会让 LED 点亮，需要取反后变为低电平 0 才能点亮，所以最后的结果需要取反后给 &lt;code&gt;LED_PORT&lt;/code&gt; 口，并且每次循环都要延时一段时间，这样才能分辨出来 LED 在流水。&lt;/p&gt;
&lt;h1 id=&#34;reference&#34;&gt;Reference&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;普中51单片机开发攻略&lt;/li&gt;
&lt;/ul&gt;
</description>
      
    </item>
    
  </channel>
</rss>
