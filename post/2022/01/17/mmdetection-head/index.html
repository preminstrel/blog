<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">

  
  <meta name="author" content="Hanshi Sun">

  
  
  <meta name="description" content="目前 MMDetection 中 Head 模块主要是按照 stage 来划分，主要包括两个 package: dense_heads 和 roi_heads ，分别对应 two-stage 算法中的第一和第二个 stage 模块，如果是 one-stage 算法则仅仅有 dense_heads 而已。 dense_heads dense_heads 部分主要是按照">
  

  
  <link rel="icon" href="https://preminstrel.github.io/blog/favicon.ico">

  
  
  <meta name="keywords" content=" hugo  latex  theme ">
  

  
  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css"
  integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
  integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js"
  integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '\\[', right: '\\]', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false }
      ],
      ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'option'],
      throwOnError: false
    });
  });
</script>


  

  
  <meta property="og:title" content="MMDetection Head" />
<meta property="og:description" content="目前 MMDetection 中 Head 模块主要是按照 stage 来划分，主要包括两个 package: dense_heads 和 roi_heads ，分别对应 two-stage 算法中的第一和第二个 stage 模块，如果是 one-stage 算法则仅仅有 dense_heads 而已。 dense_heads dense_heads 部分主要是按照" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://preminstrel.github.io/blog/post/2022/01/17/mmdetection-head/" />
<meta property="article:published_time" content="2022-01-17T13:21:36+08:00" />
<meta property="article:modified_time" content="2022-01-17T00:00:00+00:00" />


  
  <link rel="canonical" href="https://preminstrel.github.io/blog/post/2022/01/17/mmdetection-head/">

  
  
  <meta itemprop="name" content="MMDetection Head">
<meta itemprop="description" content="目前 MMDetection 中 Head 模块主要是按照 stage 来划分，主要包括两个 package: dense_heads 和 roi_heads ，分别对应 two-stage 算法中的第一和第二个 stage 模块，如果是 one-stage 算法则仅仅有 dense_heads 而已。 dense_heads dense_heads 部分主要是按照">
<meta itemprop="datePublished" content="2022-01-17T13:21:36&#43;08:00" />
<meta itemprop="dateModified" content="2022-01-17T00:00:00&#43;00:00" />
<meta itemprop="wordCount" content="2877">



<meta itemprop="keywords" content="Object Detection,Deep Learning,MMDetection," />

  
  <link media="screen" rel="stylesheet" href='https://preminstrel.github.io/blog/css/common.css'>
  <link media="screen" rel="stylesheet" href='https://preminstrel.github.io/blog/css/content.css'>

  
  
  <title>MMDetection Head - Blog de Preminstrel</title>
  

  
  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="MMDetection Head"/>
<meta name="twitter:description" content="目前 MMDetection 中 Head 模块主要是按照 stage 来划分，主要包括两个 package: dense_heads 和 roi_heads ，分别对应 two-stage 算法中的第一和第二个 stage 模块，如果是 one-stage 算法则仅仅有 dense_heads 而已。 dense_heads dense_heads 部分主要是按照"/>


  
<link rel="stylesheet" href='https://preminstrel.github.io/blog/css/single.css'>

</head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1>
    <a href="https://preminstrel.github.io/blog/">Blog de Preminstrel</a>
  </h1>

  <nav>
    
    <span class="nav-bar-item">
      <a class="link" href="/blog/">Post</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/blog/post/">Archives</a>
    </span>
    
    <span class="nav-bar-item">
      <a class="link" href="/blog/about/">About</a>
    </span>
    
  </nav>
</header>

    
<main id="main" class="post">
  
  
  <h1>MMDetection Head</h1>
  
  <div>
    <b>Keywords: </b>
    
    <a class="link" href='https://preminstrel.github.io/blog/tags/object-detection'>#Object Detection</a>
    
    <a class="link" href='https://preminstrel.github.io/blog/tags/deep-learning'>#Deep Learning</a>
    
    <a class="link" href='https://preminstrel.github.io/blog/tags/mmdetection'>#MMDetection</a>
    
  </div>
  
  
  <article class="content">
    
    <div align=center>
<img src="/img/20220117132300.jpg" width="700px"/>
</div>
<p>目前 MMDetection 中 Head 模块主要是按照 stage 来划分，主要包括两个 package: <code>dense_heads</code> 和 <code>roi_heads</code> ，分别对应 two-stage 算法中的第一和第二个 stage 模块，如果是 one-stage 算法则仅仅有 <code>dense_heads</code> 而已。</p>
<ul>
<li>
<p><em><strong>dense_heads</strong></em></p>
<p><code>dense_heads</code> 部分主要是按照  <em><strong>anchor-based</strong></em> 和 <em><strong>anchor-free</strong></em> 来划分，对应的类是 AnchorHead 和 AnchorFreeHead, 这两个类主要区别是 AnchorHead 会额外需要 <code>anchor_generator</code> 配置，用于生成默认 anchor。</p>
<p>同时可以看到有些类并没有直接继承这两个基类，例如 YOLOV3Head。原因是在该类中大部分函数处理逻辑都需要复写，为了简单就直接继承了 <code>BaseDenseHead</code>，而对于 SABLRetinaHead 而言，由于 SABL 是类似 anchor-based 和 anchor-free 混合的算法，故直接继承 <code>BaseDenseHead</code> 是最合适的做法。用户如果要进行扩展开发，可以依据开发便捷度自由选择最合适的基类进行继承。</p>
</li>
<li>
<p><em><strong>roi_heads</strong></em></p>
<p><code>roi_heads</code> 部分主要是按照第二阶段内部的 stage 个数来划分，经典的 Faster R-CNN 采用的是 StandardRoIHead，表示进行一次回归即可，而对于 Cascade R-CNN，其第二阶段内部也包括多个 stage 回归阶段，实现了 CascadeRoIHead，即可以构建任意次数的分类回归结果。</p>
</li>
</ul>
<p>总结来说，每个 Head 内部都可能包括:</p>
<ol>
<li>RoI 特征提取器 <code>roi_extractor</code></li>
<li>共享模块 <code>shared_heads</code></li>
<li>bbox 分类回归模块 <code>bbox_heads</code></li>
<li>mask 预测模块 <code>mask_heads</code></li>
</ol>
<p>其中 1、3是<strong class=chinese>必备模块</strong>。</p>
<h1 id="head-模块构建流程">Head 模块构建流程</h1>
<p>为了方便理解，首先需要回顾下 MMDetection 训练和测试流程，然后再对每个 Head 模块进行深入分析。</p>
<h2 id="train--test-of-mmd">Train &amp; Test of MMD</h2>
<ul>
<li>
<p><strong class=chinese>训练流程</strong></p>
<p>对应 two-stage 而言，具体如下所示：</p>
</li>
</ul>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic">#============= mmdet/models/detectors/two_stage.py/TwoStageDetector ============</span>
<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">forward_train</span>(<span style="color:#666">...</span>):
    <span style="color:#080;font-style:italic"># 先进行 backbone+neck 的特征提取</span>
    x <span style="color:#666">=</span> self<span style="color:#666">.</span>extract_feat(img)
    losses <span style="color:#666">=</span> <span style="color:#a2f">dict</span>()
    <span style="color:#080;font-style:italic"># RPN forward and loss</span>
    <span style="color:#a2f;font-weight:bold">if</span> self<span style="color:#666">.</span>with_rpn:
        <span style="color:#080;font-style:italic"># 训练 RPN</span>
        proposal_cfg <span style="color:#666">=</span> self<span style="color:#666">.</span>train_cfg<span style="color:#666">.</span>get(<span style="color:#b44">&#39;rpn_proposal&#39;</span>,
                                        self<span style="color:#666">.</span>test_cfg<span style="color:#666">.</span>rpn)
        <span style="color:#080;font-style:italic"># 主要是调用 rpn_head 内部的 forward_train 方法</span>
        rpn_losses, proposal_list <span style="color:#666">=</span> self<span style="color:#666">.</span>rpn_head<span style="color:#666">.</span>forward_train(x,<span style="color:#666">...</span>)
        losses<span style="color:#666">.</span>update(rpn_losses)
    <span style="color:#a2f;font-weight:bold">else</span>:
        proposal_list <span style="color:#666">=</span> proposals
    <span style="color:#080;font-style:italic"># 第二阶段，主要是调用 roi_head 内部的 forward_train 方法</span>
    roi_losses <span style="color:#666">=</span> self<span style="color:#666">.</span>roi_head<span style="color:#666">.</span>forward_train(x, <span style="color:#666">...</span>)
    losses<span style="color:#666">.</span>update(roi_losses)
    <span style="color:#a2f;font-weight:bold">return</span> losses
</code></pre></div><p>Head 模块核心是调用 <code>self.rpn_head.forward_train</code> 和 <code>self.roi_head.forward_train</code> 函数，输出 losses 和其他相关数据。</p>
<p>对于 one-stage 而言，具体如下所示：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic">#============= mmdet/models/detectors/single_stage.py/SingleStageDetector ============</span>
<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">forward_train</span>(<span style="color:#666">...</span>):
    <span style="color:#a2f">super</span>(SingleStageDetector, self)<span style="color:#666">.</span>forward_train(img, img_metas)
    <span style="color:#080;font-style:italic"># 先进行 backbone+neck 的特征提取</span>
    x <span style="color:#666">=</span> self<span style="color:#666">.</span>extract_feat(img)
    <span style="color:#080;font-style:italic"># 主要是调用 bbox_head 内部的 forward_train 方法</span>
    losses <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_head<span style="color:#666">.</span>forward_train(x, <span style="color:#666">...</span>)
    <span style="color:#a2f;font-weight:bold">return</span> losses
</code></pre></div><p>这个比 two-stage Head 模块简单，因为其只有第一个 stage，对应的函数是 <code>self.bbox_head.forward_train</code>。</p>
<ul>
<li><strong class=chinese>测试流程</strong></li>
</ul>
<ol>
<li>调用 MMDataParallel 或 MMDistributedDataParallel 中的 <code>forward</code> 方法</li>
<li>调用 base.py 中的 <code>forward</code> 方法</li>
<li>调用 base.py 中的 <code>self.forward_test</code> 方法</li>
<li>如果是单尺度测试，则会调用 TwoStageDetector 或 SingleStageDetector 中的 <code>simple_test</code> 方法，如果是多尺度测试，则调用 <code>aug_test</code> 方法</li>
<li>最终调用的是每个具体 Head 模块的 <code>simple_test</code> 或者 <code>aug_test</code> 方法(one-stage 和 two-stage 的 head 调用逻辑有些区别)</li>
</ol>
<p>可以看出在测试阶段，主要是调用了 Head 模块自身的 <code>simple_test</code> 或 <code>aug_test</code> 方法。</p>
<h2 id="dense_heads">dense_heads</h2>
<h3 id="train">Train</h3>
<p><code>dense_heads</code> 训练流程最外层函数是 <code>forward_train</code>, 其实现是在 <code>mmdet/models/dense_heads/base_dense_head.py/BaseDenseHead</code> 中，如下所示：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">forward_train</span>(self,
                  x,
                  img_metas,
                  gt_bboxes,
                  gt_labels<span style="color:#666">=</span>None,
                  gt_bboxes_ignore<span style="color:#666">=</span>None,
                  proposal_cfg<span style="color:#666">=</span>None,
                  <span style="color:#666">**</span>kwargs):
    <span style="color:#080;font-style:italic"># 调用各个子类实现的 forward 方法</span>
    outs <span style="color:#666">=</span> self(x)
    <span style="color:#a2f;font-weight:bold">if</span> gt_labels <span style="color:#a2f;font-weight:bold">is</span> None:
        loss_inputs <span style="color:#666">=</span> outs <span style="color:#666">+</span> (gt_bboxes, img_metas)
    <span style="color:#a2f;font-weight:bold">else</span>:
        loss_inputs <span style="color:#666">=</span> outs <span style="color:#666">+</span> (gt_bboxes, gt_labels, img_metas)
    <span style="color:#080;font-style:italic"># 调用各个子类实现的 loss 计算方法</span>
    losses <span style="color:#666">=</span> self<span style="color:#666">.</span>loss(<span style="color:#666">*</span>loss_inputs, gt_bboxes_ignore<span style="color:#666">=</span>gt_bboxes_ignore)
    <span style="color:#a2f;font-weight:bold">if</span> proposal_cfg <span style="color:#a2f;font-weight:bold">is</span> None:
        <span style="color:#a2f;font-weight:bold">return</span> losses
    <span style="color:#a2f;font-weight:bold">else</span>:
        <span style="color:#080;font-style:italic"># two-stage 算法还需要返回 proposal</span>
        proposal_list <span style="color:#666">=</span> self<span style="color:#666">.</span>get_bboxes(<span style="color:#666">*</span>outs, img_metas, cfg<span style="color:#666">=</span>proposal_cfg)
        <span style="color:#a2f;font-weight:bold">return</span> losses, proposal_list
</code></pre></div><p>每个算法的 Head 子类一般不会重写上述方法，<strong>但是每个 Head 子类都会重写 <code>forward</code> 和 <code>loss</code> 方法</strong>，其中 <code>forward</code> 方法用于运行 Head 网络部分输出分类回归分支的特征图，而 <code>loss</code> 方法接收 <code>forward</code> 输出，并且结合 label 计算 loss。</p>
<p><strong>(1) BaseDenseHead</strong></p>
<p><code>BaseDenseHead</code> 基类过于简单，对于 anchor-based 和 anchor-free 算法又进一步进行了继承，得到 <code>AnchorHead</code> 或者 <code>AnchorFreeHead</code> 类。在目前的各类算法实现中，绝大部分子类都是继承自 <code>AnchorHead</code> 或者 <code>AnchorFreeHead</code>，其提供了一些相关的默认操作，如果直接继承 <code>BaseDenseHead</code> 则子类需要重写大部分算法逻辑。</p>
<p><strong>(2) AnchorHead</strong></p>
<p>首先分析 <code>AnchorHead</code>，其主要是封装了 anchor 生成过程。下面对 <code>forward</code> 和 <code>loss</code> 函数进行分析</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic"># BBoxTestMixin 是多尺度测试时候调用</span>
<span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">AnchorHead</span>(BaseDenseHead, BBoxTestMixin):
    <span style="color:#080;font-style:italic"># feats 是 backbone+neck 输出的多个尺度图</span>
    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">forward</span>(self, feats):
        <span style="color:#080;font-style:italic"># 对每张特征图单独计算预测输出</span>
        <span style="color:#a2f;font-weight:bold">return</span> multi_apply(self<span style="color:#666">.</span>forward_single, feats)

    <span style="color:#080;font-style:italic"># head 模块分类回归分支输出</span>
    <span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">forward_single</span>(self, x):
        cls_score <span style="color:#666">=</span> self<span style="color:#666">.</span>conv_cls(x)
        bbox_pred <span style="color:#666">=</span> self<span style="color:#666">.</span>conv_reg(x)
        <span style="color:#a2f;font-weight:bold">return</span> cls_score, bbox_pred
</code></pre></div><p><code>forward</code> 函数比较简单，就是对多尺度特征图中每个特征图分别计算分类和回归输出即可，主要复杂度在 loss 函数中，其运行流程图如下所示：</p>
<div align=center>
<img src="/img/20220117135200.jpg" width="700px"/>
</div>
<ul>
<li>在 loss 函数中首先会调用 <code>get_anchors</code> 函数得到默认 anchor 列表。而 <code>get_anchors</code> 函数内部会先计算多尺度特征图上每个特征点位置的 anchor，然后再计算有效 anchor 标志(因为在组织 batch 时候有些图片会进行左上角 padding，这部分像素人为加的，不需要考虑 anchor)</li>
<li>然后基于 anchor、gt bbox 以及其他必备信息调用 <code>get_targets</code> 函数计算每个预测分支对应的 target。<code>get_targets</code> 函数内部会调用 <code>multi_apply(_get_targets_single)</code> 函数对每张图片单独计算 target，而 <code>_get_targets_single</code> 函数实现的功能比较多，包括：bbox assigner、bbox sampler 和 bbox encoder 三个关键环节</li>
<li>在得到 targets 后，调用 <code>loss_single</code> 函数计算每个输出尺度的 loss 值，最终返回各个分支的 loss</li>
</ul>
<p><strong>(3) AnchorFreeHead</strong></p>
<p><code>AnchorFreeHead</code> 逻辑比 <code>AnchorHead</code> 简单很多，主要是因为 anchor-free 类算法比 anchor-based 算法更加灵活多变，而且少了复杂的 anchor 生成过程，其 <code>forward</code> 方法实现和 <code>AnchorHead</code> 完全相同，而 <code>loss</code> 方法没有实现，其子类必须实现。</p>
<h3 id="test">Test</h3>
<p>前面说过在测试流程中，最终会调用 Head 模块的 <code>simple_test</code> 或 <code>aug_test</code> 方法分别进行单尺度和多尺度测试，涉及到具体代码层面，one-stage 和 two-stage 调用函数有区别，但是最终调用的依然是 Head 模块的 <code>get_bboxes</code> 方法。</p>
<p><strong>(1) AnchorHead</strong></p>
<p>在单尺度测试模式下，对于 one-stage 而言，是直接调用 <code>self.bbox_head.get_bboxes</code> 方法，如果是 <code>AnchorHead</code>，其流程是：</p>
<ol>
<li>遍历每个特征尺度输出分支，利用 <code>nms_pre</code> 配置参数对该层预测结果按照 scores 值进行从大到小进行 topk 截取，保留 scores 最高的前 <code>nms_pre</code> 的预测结果</li>
<li>对保留的预测结果进行 bbox 解码还原操作</li>
<li>还原到最原始图片尺度</li>
<li>如果需要进行 nms，则对所有分支预测保留结果进行统一 nms 即可，否则直接属于多尺度预测结果</li>
</ol>
<p>对于 two-stage 而言，其第一阶段 Head 推理是直接调用了 <code>simple_test_rpn</code> 方法，该方法内部最终也是调用了 <code>AnchorHead</code> 中的<code>get_bboxes</code> 方法。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#080;font-style:italic"># mmdet/models/dense_heads/rpn_test_mixin.py/RPNTestMixin</span>
<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">simple_test_rpn</span>(self, x, img_metas):
    rpn_outs <span style="color:#666">=</span> self(x)
    proposal_list <span style="color:#666">=</span> self<span style="color:#666">.</span>get_bboxes(<span style="color:#666">*</span>rpn_outs, img_metas)
    <span style="color:#a2f;font-weight:bold">return</span> proposal_list
</code></pre></div><p><strong>(2) AnchorFreeHead</strong></p>
<p><code>AnchorFreeHead</code> 比较灵活， <code>get_bboxes</code> 都是由具体算法子类实现。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">get_bboxes</span>(self,
               cls_scores,
               bbox_preds,
               img_metas,
               cfg<span style="color:#666">=</span>None,
               rescale<span style="color:#666">=</span>None):
    <span style="color:#a2f;font-weight:bold">raise</span> <span style="color:#d2413a;font-weight:bold">NotImplementedError</span>
</code></pre></div><p><strong>(3) 多尺度测试</strong></p>
<p>除了 RPN 算法的多尺度测试是在<code>mmdet/models/dense_heads/rpn_test_mixin.py</code>，其余 Head 多尺度测试都是在 <code>mmdet/models/dense_heads/dense_test_mixins.py/BBoxTestMixin</code> 中实现，其思路是对多尺度图片中每张图片单独运行 <code>get_bboxes</code>，然后还原到原图尺度，最后把多尺度图片预测结果合并进行统一 nms。</p>
<h2 id="roi_heads">roi_heads</h2>
<p>以最常用的 StandardRoIHead 为例进行分析。</p>
<h3 id="train-1">Train</h3>
<p>训练流程最外层依然是调用 <code>forward_train</code>, 其核心代码如下所示：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">forward_train</span>(self,
                  x,
                  img_metas,
                  proposal_list,
                  gt_bboxes,
                  gt_labels,
                  <span style="color:#666">...</span>):
    <span style="color:#a2f;font-weight:bold">if</span> self<span style="color:#666">.</span>with_bbox <span style="color:#a2f;font-weight:bold">or</span> self<span style="color:#666">.</span>with_mask:
        num_imgs <span style="color:#666">=</span> <span style="color:#a2f">len</span>(img_metas)
        sampling_results <span style="color:#666">=</span> []
        <span style="color:#a2f;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#a2f">range</span>(num_imgs):
            <span style="color:#080;font-style:italic"># 对每张图片进行 bbox 正负样本属性分配</span>
            assign_result <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_assigner<span style="color:#666">.</span>assign(
                proposal_list[i], <span style="color:#666">...</span>)
            <span style="color:#080;font-style:italic"># 然后进行正负样本采样</span>
            sampling_result <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_sampler<span style="color:#666">.</span>sample(
                assign_result,
                proposal_list[i],
                <span style="color:#666">...</span>)
            sampling_results<span style="color:#666">.</span>append(sampling_result)
    losses <span style="color:#666">=</span> <span style="color:#a2f">dict</span>()

    <span style="color:#a2f;font-weight:bold">if</span> self<span style="color:#666">.</span>with_bbox:
        <span style="color:#080;font-style:italic"># bbox 分支 forward，返回 loss</span>
        bbox_results <span style="color:#666">=</span> self<span style="color:#666">.</span>_bbox_forward_train(<span style="color:#666">...</span>)
        losses<span style="color:#666">.</span>update(bbox_results[<span style="color:#b44">&#39;loss_bbox&#39;</span>])

    <span style="color:#a2f;font-weight:bold">if</span> self<span style="color:#666">.</span>with_mask:
        <span style="color:#080;font-style:italic"># mask 分支 forward,返回 loss</span>
    <span style="color:#a2f;font-weight:bold">return</span> losses


<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">_bbox_forward_train</span>(self, x, sampling_results, gt_bboxes, gt_labels,
                        img_metas):
    rois <span style="color:#666">=</span> bbox2roi([res<span style="color:#666">.</span>bboxes <span style="color:#a2f;font-weight:bold">for</span> res <span style="color:#a2f;font-weight:bold">in</span> sampling_results])
    <span style="color:#080;font-style:italic"># forward</span>
    bbox_results <span style="color:#666">=</span> self<span style="color:#666">.</span>_bbox_forward(x, rois)
    <span style="color:#080;font-style:italic"># 计算 target</span>
    bbox_targets <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_head<span style="color:#666">.</span>get_targets(<span style="color:#666">...</span>)  
    <span style="color:#080;font-style:italic"># 计算 loss                                          </span>
    loss_bbox <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_head<span style="color:#666">.</span>loss(<span style="color:#666">...</span>)
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">...</span>    

<span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">_bbox_forward</span>(self, x, rois):
    <span style="color:#080;font-style:italic"># roi 提取</span>
    bbox_feats <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_roi_extractor(
        x[:self<span style="color:#666">.</span>bbox_roi_extractor<span style="color:#666">.</span>num_inputs], rois)
    <span style="color:#080;font-style:italic"># bbox head 网络前向</span>
    cls_score, bbox_pred <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_head(bbox_feats)
    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">...</span>
</code></pre></div><p>从上述逻辑可以看出，<code>StandardRoIHead</code> 中 <code>forward_train</code> 函数仅仅是对内部的 <code>bbox_head</code> 相关函数进行调用，例如 <code>get_targets</code> 和 <code>loss</code>，本身 StandardRoIHead 类不做具体算法逻辑计算。</p>
<p>可以参考 Faster R-CNN 配置文件理解 <code>StandardRoIHead</code> 和 <code>bbox_head</code> 的关系：</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">roi_head<span style="color:#666">=</span><span style="color:#a2f">dict</span>(
    <span style="color:#a2f">type</span><span style="color:#666">=</span><span style="color:#b44">&#39;StandardRoIHead&#39;</span>,
    bbox_roi_extractor<span style="color:#666">=</span><span style="color:#a2f">dict</span>(
        <span style="color:#a2f">type</span><span style="color:#666">=</span><span style="color:#b44">&#39;SingleRoIExtractor&#39;</span>,
        roi_layer<span style="color:#666">=</span><span style="color:#a2f">dict</span>(<span style="color:#a2f">type</span><span style="color:#666">=</span><span style="color:#b44">&#39;RoIAlign&#39;</span>, output_size<span style="color:#666">=</span><span style="color:#666">7</span>, sampling_ratio<span style="color:#666">=</span><span style="color:#666">0</span>),
        out_channels<span style="color:#666">=</span><span style="color:#666">256</span>,
        featmap_strides<span style="color:#666">=</span>[<span style="color:#666">4</span>, <span style="color:#666">8</span>, <span style="color:#666">16</span>, <span style="color:#666">32</span>]),
    bbox_head<span style="color:#666">=</span><span style="color:#a2f">dict</span>(
        <span style="color:#a2f">type</span><span style="color:#666">=</span><span style="color:#b44">&#39;Shared2FCBBoxHead&#39;</span>,
        in_channels<span style="color:#666">=</span><span style="color:#666">256</span>,
        fc_out_channels<span style="color:#666">=</span><span style="color:#666">1024</span>,
        roi_feat_size<span style="color:#666">=</span><span style="color:#666">7</span>,
        num_classes<span style="color:#666">=</span><span style="color:#666">80</span>,
        bbox_coder<span style="color:#666">=</span><span style="color:#a2f">dict</span>(
            <span style="color:#a2f">type</span><span style="color:#666">=</span><span style="color:#b44">&#39;DeltaXYWHBBoxCoder&#39;</span>,
            target_means<span style="color:#666">=</span>[<span style="color:#666">0.</span>, <span style="color:#666">0.</span>, <span style="color:#666">0.</span>, <span style="color:#666">0.</span>],
            target_stds<span style="color:#666">=</span>[<span style="color:#666">0.1</span>, <span style="color:#666">0.1</span>, <span style="color:#666">0.2</span>, <span style="color:#666">0.2</span>]),
        reg_class_agnostic<span style="color:#666">=</span>False,
        loss_cls<span style="color:#666">=</span><span style="color:#a2f">dict</span>(
            <span style="color:#a2f">type</span><span style="color:#666">=</span><span style="color:#b44">&#39;CrossEntropyLoss&#39;</span>, use_sigmoid<span style="color:#666">=</span>False, loss_weight<span style="color:#666">=</span><span style="color:#666">1.0</span>),
        loss_bbox<span style="color:#666">=</span><span style="color:#a2f">dict</span>(<span style="color:#a2f">type</span><span style="color:#666">=</span><span style="color:#b44">&#39;L1Loss&#39;</span>, loss_weight<span style="color:#666">=</span><span style="color:#666">1.0</span>))))
</code></pre></div><p><code>StandardRoIHead</code> 类包装了 <code>bbox_roi_extractor</code> 和 <code>bbox_head</code> 的实例，前者用于 RoI 特征提取，后者才是真正计算分类和回归的逻辑。在 <code>bbox_head</code> 中除了网络模型有些变换外，loss计算过程是非常类似的，其 <code>get_targets</code> 和 <code>loss</code> 计算过程都是封装在基类 <code>mmdet/models/roi_heads/bbox_heads/bbox_head.py</code> 中。</p>
<h3 id="test-1">Test</h3>
<p>测试流程是调用 Head 模块的 <code>simple_test</code> 和 <code>aug_test</code> 函数，单尺度测试 bbox 相关实现代码在 <code>mmdet/models/roi_heads/test_mixins.py/BBoxTestMixin</code> 的 <code>simple_test_bboxes</code> 函数中。</p>
<div class="highlight"><pre style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#a2f;font-weight:bold">def</span> <span style="color:#00a000">simple_test_bboxes</span>(self,
                       x,
                       <span style="color:#666">...</span>):
    rois <span style="color:#666">=</span> bbox2roi(proposals)
    <span style="color:#080;font-style:italic"># roi 提取+ forward，输出预测结果</span>
    bbox_results <span style="color:#666">=</span> self<span style="color:#666">.</span>_bbox_forward(x, rois)
    cls_score <span style="color:#666">=</span> bbox_results[<span style="color:#b44">&#39;cls_score&#39;</span>]
    bbox_pred <span style="color:#666">=</span> bbox_results[<span style="color:#b44">&#39;bbox_pred&#39;</span>]
    det_bboxes <span style="color:#666">=</span> []
    det_labels <span style="color:#666">=</span> []
    <span style="color:#a2f;font-weight:bold">for</span> i <span style="color:#a2f;font-weight:bold">in</span> <span style="color:#a2f">range</span>(<span style="color:#a2f">len</span>(proposals)):
        <span style="color:#080;font-style:italic"># 对预测结果进行解码输出 bbox 和对应 label</span>
        det_bbox, det_label <span style="color:#666">=</span> self<span style="color:#666">.</span>bbox_head<span style="color:#666">.</span>get_bboxes(<span style="color:#666">...</span>)
        det_bboxes<span style="color:#666">.</span>append(det_bbox)
        det_labels<span style="color:#666">.</span>append(det_label)
    <span style="color:#a2f;font-weight:bold">return</span> det_bboxes, det_labels
</code></pre></div><p>实际上依然是调用了 Head 模块内部的 <code>get_bboxes</code> 函数，处理逻辑和 dense_head 差不多( 解码+还原尺度+ nms)。</p>
<h1 id="conclusion">Conclusion</h1>
<p>本文对最复杂的 Head 模块进行深入详细解读，我们应该掌握：</p>
<ul>
<li>MMDetection 框架的整体设计思想和算法模块划分原则</li>
<li>MMDetection 框架的整体训练和测试流程</li>
<li>MMDetection 框架每个组件的详细代码实现过程</li>
<li>针对任何一个新复现代码，能够很快理解 MMDetection 是如何通过模块组合实现的</li>
</ul>
<h1 id="reference">Reference</h1>
<ul>
<li>原文：<a href="https://zhuanlan.zhihu.com/p/343433169">轻松掌握 MMDetection 中 Head 流程</a></li>
</ul>

    
  </article>
  <div class="paginator">
    
    <a class="link" href="https://preminstrel.github.io/blog/post/2022/01/16/mmdetection-framework/">← prev</a>
    
    
    <a class="link" href="https://preminstrel.github.io/blog/post/2022/01/26/self-attention/">next →</a>
    
  </div>
  <div class="comment">
    
    
    
    
    
    
  </div>
  
</main>

    <footer id="footer">
  <div>
    <span>© 2021</span> - <span>2022</span>
  </div>

  <div>
    <span>Powered by </span>
    <a class="link" href="https://gohugo.io/">Hugo</a>
    <span> 🍦 Theme </span>
    <a class="link" href="https://github.com/queensferryme/hugo-theme-texify">TeXify</a>
  </div>

  <div class="footnote">
    <span>Follow me on <a class=link href=https://github.com/preminstrel>GitHub</a>,
<a class=link href=https://twitter.com/preminstrel>Twitter</a> or
<a class=link href=/index.xml>RSS</a> |
<a class=link href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a>
</span>
  </div>
</footer>

  </div>

  
  

  
  

  
  

</body>

</html>
